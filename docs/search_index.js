var documenterSearchIndex = {"docs":
[{"location":"operatorandutil.html#Operators-and-utilities","page":"Operators and utilities","title":"Operators and utilities","text":"","category":"section"},{"location":"io.html#Input/Output","page":"I/O","title":"Input/Output","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"Here is a documentation for functions related to saving simulation state and data files, based on the provided source code:","category":"page"},{"location":"io.html#Saving-Simulation-Data","page":"I/O","title":"Saving Simulation Data","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The PeriDyn package provides several functions for saving simulation data to files. These functions allow you to store the state of your simulations at various points during the simulation, which can be useful for post-processing, visualization, and analysis.","category":"page"},{"location":"io.html#File-Path-Generation","page":"I/O","title":"File Path Generation","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The filepath_ function generates the path to the output folder for your simulation data.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"filepath_(file_prefix::String; append_date=false)\nArguments:\nfile_prefix: A string representing the prefix of the output folder.\nKeyword Arguments:\nappend_date: A boolean value indicating whether to append the current date and time to the output folder name. Defaults to false.\nReturns:\nA string representing the full path to the output folder. The function also creates the folder if it doesn't exist.\nExample:","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"filepath_(\"my_simulation_data\", append_date = true)\n# Returns: \"my_simulation_data_2023-10-26T16-35-12/\" \n# (assuming the current date and time is 2023-10-26 16:35:12)","category":"page"},{"location":"io.html#Saving-Simulation-State","page":"I/O","title":"Saving Simulation State","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The save_state! and save_state_ovito_bc! functions save the state of your simulation environment to a file.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"save_state!(filename, env; force=false)\nArguments:\nfilename: A string representing the name of the file to save the data to.\nenv: A GeneralEnvironment object representing the simulation environment to be saved.\nKeyword Arguments:\nforce: A boolean value indicating whether to force saving to data file format even if the data size is large. Defaults to false. If set to false and the data size is large, the function automatically switches to the more efficient .jld2 format.\nThis function saves the following data for each particle in the simulation:\nid\ntype\nposition\nvelocity\nacceleration\nmass\nvolume\ndamage\nExample:","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"save_state!(\"my_simulation_state.data\", env)","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"save_state_ovito_bc!(filename, env; force=false)\nThis function works similarly to save_state! but it encodes the boundary condition information into the particle types. This is particularly useful if you plan to visualize the simulation data in Ovito, as it allows you to distinguish between particles belonging to different boundary conditions.\nExample:","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"save_state_ovito_bc!(\"my_simulation_state.data\", env)","category":"page"},{"location":"io.html#Saving-Global-Data","page":"I/O","title":"Saving Global Data","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The write_global_data function saves global simulation data to a .jld2 file.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"write_global_data(filename; kwargs...)\nArguments:\nfilename: A string representing the name of the .jld2 file.\nkwargs...: Keyword arguments representing the global data to be saved. The keys should be symbols, and the values should be arrays or other serializable objects.\nExample:","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"write_global_data(\"global_data.jld2\", total_energy = energy_history, total_momentum = momentum_history)","category":"page"},{"location":"io.html#Saving-Data-at-Intervals","page":"I/O","title":"Saving Data at Intervals","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The print_data_file! function saves both the simulation state and global data to separate files at specified intervals during the simulation.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"print_data_file!(envs::Array{GeneralEnvironment}, file_prefix::String, i::Int64)\nArguments:\nenvs: An array of GeneralEnvironment objects representing the simulation environments.\nfile_prefix: A string representing the prefix for the output files.\ni: An integer representing the current step number.\nThis function automatically appends the environment ID and step number to the file names.\nExample:","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"print_data_file!([env1, env2], \"simulation_data\", 10) \n# Creates files like \"simulation_data/env_1_step_10.jld2\", \n# \"simulation_data/env_2_step_10.jld2\", etc.","category":"page"},{"location":"io.html#Data-File-Formats","page":"I/O","title":"Data File Formats","text":"","category":"section"},{"location":"io.html","page":"I/O","title":"I/O","text":"The save_state!, save_state_ovito_bc!, and print_data_file! functions can save data in either .data or .jld2 format.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"The .data format is a simple text-based format that is compatible with Ovito. However, it can be inefficient for large simulations.\nThe .jld2 format is a binary format that is more efficient for storing large amounts of data.","category":"page"},{"location":"io.html","page":"I/O","title":"I/O","text":"By default, these functions will attempt to save data in .data format unless the force keyword argument is set to true or the data size exceeds a certain threshold. In those cases, the functions will automatically switch to .jld2 format. You can also explicitly specify the desired file format by using the appropriate file extension (e.g., \".data\" or \".jld2\") in the filename argument.","category":"page"},{"location":"autodocs.html#Automatic-documentation","page":"Autodocs","title":"Automatic documentation","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Table of contents on this page.","category":"page"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Pages = [\n            \"autodocs.md\"\n        ]\nDepth = 4","category":"page"},{"location":"autodocs.html#Peridynamics-functions","page":"Autodocs","title":"Peridynamics functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"peri.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.__I-Tuple{AbstractArray}","page":"Autodocs","title":"PeriDyn.__I","text":"__I(x::AbstractArray)\n\nReturns x of the same type as of x (identity function). It is not a true identity function as it does not return a copy of x but returns x itself.\n\nArguments\n\nx::AbstractArray: input array\n\nReturns\n\nx: x of the same type as of x (identity function)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.__O-Tuple{AbstractArray}","page":"Autodocs","title":"PeriDyn.__O","text":"__O(x::AbstractArray)\n\nReturns zero of the same type as of x.\n\nArguments\n\nx::AbstractArray: input array\n\nReturns\n\nzero(x): zero of the same type as of x\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.__norm-Tuple{AbstractArray}","page":"Autodocs","title":"PeriDyn.__norm","text":"__norm(x::AbstractArray)\n\nReturns magnitude of x (lVert x rVert).\n\nArguments\n\nx::AbstractArray: input array\n\nReturns\n\ny: magnitude of x\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.__unit-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Autodocs","title":"PeriDyn.__unit","text":"__unit(x::AbstractArray)\n\nReturns unit vector of x.\n\nArguments\n\nx::AbstractArray: input array\n\nReturns\n\ny: unit vector of x\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.cal_damage-Tuple{Any}","page":"Autodocs","title":"PeriDyn.cal_damage","text":"cal_damage(env)\n\nCalculates damage for each bond for a given environment.\n\nArguments\n\nenv: environment\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.cal_family!-Union{Tuple{T1}, Tuple{T}, Tuple{Matrix{Int64}, Matrix{T}, T1}} where {T, T1}","page":"Autodocs","title":"PeriDyn.cal_family!","text":"cal_family!(family, x, horizon)\n\nCalculates family for given positions and horizon.\n\nArguments\n\nfamily: family\nx: positions\nhorizon: horizon\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.cal_family-Union{Tuple{T1}, Tuple{T}, Tuple{Matrix{T}, T1, Int64}} where {T, T1}","page":"Autodocs","title":"PeriDyn.cal_family","text":"cal_family(x, horizon, max_neigh)\n\nCalculates family for given positions and horizon.\n\nArguments\n\nx: positions\nhorizon: horizon\nmax_neigh: maximum number of neighbors\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.cell_number-NTuple{4, Any}","page":"Autodocs","title":"PeriDyn.cell_number","text":"cell_number(i, j, k, N)\n\nCalculates cell number for given i,j,k cell indices (when in a list).\n\nArguments\n\ni: cell index in x direction\nj: cell index in y direction\nk: cell index in z direction\nN: number of cells in each direction\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.dilatation!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Type{Val{:cuda}}}","page":"Autodocs","title":"PeriDyn.dilatation!","text":"dilatation!(theta, y, x, intact, family, volume, m, particle_size, horizon, device::Type{Val{:cuda}})\n\nIt gives dilatation as given ordinary state material model.\n\ntheta_i = frac3m_i sum_j in mathcalN_i omega_ij times lVert X_ij rVert times e_ij times vol_j times s_ij\n\nwhere, omega_ij is influence function, X_ij is x_j - x_i, e_ij is bond extention, vol_j is particle volume, s_ijis horizon correction factor.\n\nArguments\n\ntheta: dilatation\ny: deformed positions\nx: initial positions\nintact: intact bonds\nfamily: family of particles\nvolume: particle volume\nm: mass\nparticle_size: particle size\nhorizon: horizon\ndevice::Type{Val{:cuda}}: device type\n\nReturns\n\nnothing: theta is updated in-place\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.dilatation!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.dilatation!","text":"dilatation!(theta, y, x, intact, family, volume, m, particle_size, horizon, device::Type{Val{:cpu}})\n\nIt gives dilatation as given ordinary state material model.\n\ntheta_i = frac3m_i sum_j in mathcalN_i omega_ij times lVert X_ij rVert times e_ij times vol_j times s_ij\n\nwhere, omega_ij is influence function, X_ij is x_j - x_i, e_ij is bond extention, vol_j is particle volume, s_ijis horizon correction factor.\n\nArguments\n\ntheta: dilatation\ny: deformed positions\nx: initial positions\nintact: intact bonds\nfamily: family of particles\nvolume: particle volume\nm: weighted volume\nparticle_size: particle size\nhorizon: horizon\ndevice::Type{Val{:cpu}}: device type\n\nReturns\n\nnothing: theta is updated in-place\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.dilatation!-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.dilatation!","text":"dilatation!(y, mat, device)\n\nIt gives dilatation as given by ordinary state material model. Calls dilatation!(theta, y, x, intact, family, volume, m, particle_size, horizon, device).\n\nArguments\n\ny: deformed positions\nmat: material model\ndevice: device type\n\nReturns\n\nnothing: In-place operation\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.dilatation-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.dilatation","text":"dilatation(y, x, intact, family, volume, m, particle_size, horizon, device::Type{Val{:cpu}})\n\nIt gives dilatation as given ordinary state material model.\n\ntheta_i = frac3m_i sum_j in mathcalN_i omega_ij times lVert X_ij rVert times e_ij times vol_j times s_ij\n\nwhere, omega_ij is influence function, X_ij is x_j - x_i, e_ij is bond extention, vol_j is particle volume, s_ijis horizon correction factor.\n\nArguments\n\ny: deformed positions\nx: initial positions\nintact: intact bonds\nfamily: family of particles\nvolume: particle volume\nm: mass\nparticle_size: particle size\nhorizon: horizon\ndevice::Type{Val{:cpu}}: device type\n\nReturns\n\ntheta: dilatation\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.dilatation-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Type{Val{:cuda}}}","page":"Autodocs","title":"PeriDyn.dilatation","text":"dilatation(y, x, intact, family, volume, m, particle_size, horizon, device::Type{Val{:cuda}})\n\nIt gives dilatation as given ordinary state material model.\n\ntheta_i = frac3m_i sum_j in mathcalN_i omega_ij times lVert X_ij rVert times e_ij times vol_j times s_ij\n\nwhere, omega_ij is influence function, X_ij is x_j - x_i, e_ij is bond extention, vol_j is particle volume, s_ijis horizon correction factor.\n\nArguments\n\ny: deformed positions\nx: initial positions\nintact: intact bonds\nfamily: family of particles\nvolume: particle volume\nm: mass\nparticle_size: particle size\nhorizon: horizon\ndevice::Type{Val{:cuda}}: device type\n\nReturns\n\ntheta: dilatation\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_cells-Union{Tuple{T1}, Tuple{T}, Tuple{AbstractMatrix{T}, T1}} where {T, T1}","page":"Autodocs","title":"PeriDyn.get_cells","text":"get_cells(x, horizon; max_part=30)\n\nCalculates cells for given positions and horizon.\n\nArguments\n\nx: positions\nhorizon: horizon\n\nKeyword Arguments\n\nmax_part=30: number of partitions in each direction\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.horizon_correction-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.horizon_correction","text":"horizon_correction(dr, ps, hr)\n\nIt gives horizon correction factor (It will give 1 as of now).\n\nArguments\n\ndr: X_ij\nps: particle size\nhr: horizon\n\nReturns\n\ns: horizon correction factor\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.influence_function-Tuple{Any}","page":"Autodocs","title":"PeriDyn.influence_function","text":"influence_function(dr)\n\nIt gives influence function as given ordinary state material model. Return frac1 lVert dr rVert as of now.\n\nArguments\n\ndr: X_ij\n\nReturns\n\nomega_ij: influence function\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.loop_over_neighs!-NTuple{4, Any}","page":"Autodocs","title":"PeriDyn.loop_over_neighs!","text":"loop_over_neighs!(y_, mat, fn_map, device; fn_reduce=(args...)->())\n\nThe function loops over neighbors and applies fn_map to each neighbor and fn_reduce to reduce the results.\n\nThe function fn_map should have the following signature:\n\nfn_map(mat, i, j, k, type1, type2,\n                                xij, yij, extension, s,\n                                wij, wji, items)\n\nwhere,\n\nmat: material model\ni: particle index\nj: neighbor index\nk: family index\ntype1: type of particle i\ntype2: type of particle j\nxij: x_j - x_i\nyij: y_j - y_i\nextension: y_j - y_i\ns: s_ij bond stretch\nwij: influence function w_ij\nwji: influence function w_ji\nitems: output of get_items(mat) function\n\nThe function fn_reduce should have the following signature:\n\nfn_reduce(mat, i, items)\n\nwhere,\n\nmat: material model\ni: particle index\nitems: output of get_items(mat) function\n\nArguments\n\ny_: deformed positions\nmat: material model\nfn_map: function to be applied to each neighbor\ndevice::Type{Val{:cuda}}: device type\n\nKeyword Arguments\n\nfn_reduce=(args...)->(): function to reduce the results\n\nReturns\n\nnothing: y_ is updated in-place\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.neigh_cells-NTuple{4, Any}","page":"Autodocs","title":"PeriDyn.neigh_cells","text":"neigh_cells(i, j, k, N)\n\nCalculates neighbor cells for given i,j,k cell indices (when in a list).\n\nArguments\n\ni: cell index in x direction\nj: cell index in y direction\nk: cell index in z direction\nN: number of cells in each direction\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.weighted_volume-NTuple{5, Any}","page":"Autodocs","title":"PeriDyn.weighted_volume","text":"weighted_volume(x, volume, particle_size, family, horizon)\n\nIt gives weighted volume as given ordinary state material model.\n\nm_i = sum_j in mathcalN_i omega_ij times lVert X_ij rVert^2 times vol_j times s_ij\n\nwhere,\n\nomega_ij: influence function\nX_ij: x_j - x_i\nvol_j: particle volume\ns_ij: horizon correction\n\nArguments\n\nx: initial positions\nvolume: particle volume\nparticle_size: particle size\nfamily: family of particles\nhorizon: horizon\n\nReturns\n\nm: weighted volume\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Simulation-environment","page":"Autodocs","title":"Simulation environment","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"environment.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.GeneralEnvironment","page":"Autodocs","title":"PeriDyn.GeneralEnvironment","text":"GeneralEnvironment <: SimulationEnvironment\n\nType for holding parameters for a simulation.\n\nFields\n\nid::Int64: ID of the environment\ntype::AbstractArray{Int64,1}: Type of each particle\nbid::AbstractArray{Int64,1}: Block ID of each particle\nghost_particles::AbstractArray{Int64,1}: Ghost particles\nstate::Int64: State of the environment\ntime_step::Int64: Time step of the environment\ndt::T where T<:QF: Time step size\ny::AbstractArray{T,2} where T<:QF: Position of each particle\nv::AbstractArray{T,2} where T<:QF: Velocity of each particle\nf::AbstractArray{T,2} where T<:QF: Force of each particle\np::AbstractArray{T,2} where T<:QF: Momentum of each particle\nvolume::AbstractArray{T,1} where T<:QF: Volume of each particle\nmass::AbstractArray{T,1} where T<:QF: Mass of each particle\ndensity::AbstractArray{T,1} where T<:QF: Density of each particle\nintact0::AbstractArray{Int64, 1}: Intact particles information\nneighs::AbstractArray{Int64,2}: Neighbors of each particle\nboundary_conditions::AbstractArray{T, 1} where T: Boundary conditions\nshort_range_contact::AbstractArray{T, 1} where T: Short range contact\nmaterial_blocks::AbstractArray{T, 1} where T: Material blocks\nboundaries::Tuple: Boundaries\nCollect!::Function: Function for collecting data\nParams::Dict{Symbol, Any}: Parameters\nOut::Dict{Symbol, Any}: Output\ncprint::Function: Function for printing\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.SimulationEnvironment","page":"Autodocs","title":"PeriDyn.SimulationEnvironment","text":"SimulationEnvironment\n\nAbstract type for holding parameters for a simulation.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.Env-Tuple{Int64, Vararg{Any, 4}}","page":"Autodocs","title":"PeriDyn.Env","text":"Env(id::Int64, materials,short_range_contact, boundary_conds, dt; state=2, bskin=0.5, units=false)\n\nConstructor for GeneralEnvironment type.\n\nArguments\n\nid::Int64: Environment ID\nmaterials::AbstractArray{Material, 1}: Materials\nshort_range_contact::AbstractArray{ContactModel, 1}: Short range contact models\nboundary_conds::AbstractArray{BoundaryCondition, 1}: Boundary conditions\ndt::T where T<:QF: Time step\nstate::Int64: State of the environment\nbskin::T where T<:QF: Boundary skin\nunits::Bool: Units\n\nReturns\n\nenv::GeneralEnvironment: General environment\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.printdata-Tuple{Any}","page":"Autodocs","title":"PeriDyn.printdata","text":"printdata(env)\n\nPrint (and save to log.txt) data of an environment during simulation.\n\nIf PRINT_DEFAULT_DATA is set to true, the following data will be printed:\n\nenvID: Environment ID\ntime: Simulation time\npx, py, pz: Total momentum in x, y, z directions\nFx, Fy, Fz: Total force in x, y, z directions\ndamage: Total damage\nand the data printed by cprint function of the environment\n\nArguments\n\nenv: Environment\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_env_active!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.set_env_active!","text":"set_env_active!(env)\n\nSet environment state active.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_env_idel!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.set_env_idel!","text":"set_env_idel!(env)\n\nSet environment state idel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_env_inactive!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.set_env_inactive!","text":"set_env_inactive!(env)\n\nSet environment state inactive.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_ghost_particles!-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.set_ghost_particles!","text":"set_ghost_particles!(env,ghost_particles)\n\nSet ghost particles for an environment.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Material-models","page":"Autodocs","title":"Material models","text":"","category":"section"},{"location":"autodocs.html#General-material-models-and-functions","page":"Autodocs","title":"General material models and functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages = [\"material.jl\", \"general_material.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.GeneralMaterial","page":"Autodocs","title":"PeriDyn.GeneralMaterial","text":"GeneralMaterial\n\nGeneral peridynamics material type.\n\nFields\n\ny::AbstractArray{Float64,2}: Deformed position of the material.\nvelocity::AbstractArray{Float64,2}: Velocity of the material.\nx::AbstractArray{Float64,2}: Position of the material.\nvolume::AbstractArray{Float64,1}: Volume of the material.\ntype::AbstractArray{Int64,1}: Type of the material.\nparticle_size::Float64: Particle size of the material.\nhorizon::Float64: Horizon of the material.\nfamily::VeryBigArray{Int64,2}: Family of the material.\nintact::VeryBigArray{Bool, 2}: Intact of the material.\nweighted_volume::AbstractArray{Float64,1}: Weighted volume of the material.\ndeformed::AbstractVector{Bool}: Deformed of the material.\nskip_bb::Bool: Skip bond based material (no idea why it is there).\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.GeneralMaterial-NTuple{6, Any}","page":"Autodocs","title":"PeriDyn.GeneralMaterial","text":"GeneralMaterial(y0, v0, x, volume, type, horizon; max_neigh=100, particle_size=0, skip_bb=false)\n\nCreates a GeneralMaterial type.\n\nArguments\n\ny0::AbstractArray{Float64,2}: Initial Deformed position of the material.\nv0::AbstractArray{Float64,2}: Initial velocity of the material.\nx::AbstractArray{Float64,2}: Initial position of the material.\nvolume::AbstractArray{Float64,1}: Volume of the material.\ntype::AbstractArray{Int64,1}: Type of the material.\nhorizon::Float64: Horizon of the material.\n\nKeyword Arguments\n\nmax_neigh::Int64 = 100: Maximum number of neighbors.\nparticle_size::Float64 = 0: Particle size of the material.\nskip_bb::Bool = false: Skip bond based material.\n\nReturns\n\nmat::GeneralMaterial: General material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.GeneralMaterial-Tuple{Dict, Vararg{Any}}","page":"Autodocs","title":"PeriDyn.GeneralMaterial","text":"GeneralMaterial(items::Dict, args...; kwargs...)\n\nCreates a GeneralMaterial type.\n\nArguments\n\nitems::Dict: Dictionary of the fields of the GeneralMaterial type.\nargs...: Arguments of the GeneralMaterial type.\nkwargs...: Keyword arguments of the GeneralMaterial type.\n\nReturns\n\nmat::GeneralMaterial: General material type.\n\nSee also\n\nGeneralMaterial\nGeneralMaterial(y0, v0, x, volume, type, horizon; max_neigh=100, particle_size=0, skip_bb=false)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial\n\nAbstract Peridynamics material type.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-NTuple{5, Any}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(name, type, bid, gen, spc)\n\nCreates a peridynamics material type with given name, type, block id, general material type and specific material type.\n\nArguments\n\nname::String: Name of the material.\ntype::Union{UnitRange{Int64}, AbstractVector{Int64}}: Type of the material.\nbid::Int64: Block id of the material.\ngen::GeneralMaterial: General material type.\nspc::SpecificMaterial: Specific material type.\n\nReturns\n\nmat::PeridynamicsMaterial: Peridynamics material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(bid, gen, spc; name=\"PeridynamicsMaterial\")\n\nCreates a peridynamics material type with given block id, general and specific material type. name is optional.\n\nArguments\n\nbid::Int64: Block id of the material.\ngen::GeneralMaterial: General material type.\nspc::SpecificMaterial: Specific material type.\nname::String: Name of the material.\n\nReturns\n\nmat::PeridynamicsMaterial: Peridynamics material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(gen, spc; name=\"PeridynamicsMaterial\")\n\nCreates a peridynamics material type with given general and specific material type. name is optional.\n\nArguments\n\ngen::GeneralMaterial: General material type.\nspc::SpecificMaterial: Specific material type.\nname::String: Name of the material.\n\nReturns\n\nmat::PeridynamicsMaterial: Peridynamics material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.SpecificMaterial","page":"Autodocs","title":"PeriDyn.SpecificMaterial","text":"SpecificMaterial\n\nAbstract specific material type.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.force_density!-Tuple{Any, Any, Any, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.force_density!","text":"force_density!(f, y, limits, mat::PeridynamicsMaterial)\n\nCalculates the force density of the material. Calls force_density_T with device if all the particles are deformed.\n\nArguments\n\nf::AbstractArray: Force of the material.\ny::AbstractArray: Deformed position of the material.\nlimits::AbstractVector{Int64}: Limits of the material.\nmat::PeridynamicsMaterial: Peridynamics material type.\n\nReturns\n\nnothing: In-place modification of f.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_T!-Tuple{Any, Any, Any, PeridynamicsMaterial, Symbol}","page":"Autodocs","title":"PeriDyn.force_density_T!","text":"force_density_T!(f, y, limits, mat::PeridynamicsMaterial, device::Symbol)\n\nCalculates force density of material pair particles. Converts device to Type{Val{:device}} and calls force_density_T.\n\nArguments\n\nf::AbstractArray: Force of the material.\ny::AbstractArray: Deformed position of the material.\nlimits::AbstractVector{Int64}: Limits of the material.\nmat::PeridynamicsMaterial: Peridynamics material type.\ndevice::Symbol: Device\n\nReturns\n\nnothing: In-place modification of f.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_T!-Tuple{Any, Any, Any, PeridynamicsMaterial, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.force_density_T!","text":"force_density_T!(f, y, limits, mat::GeneralMaterial, device::Type{Val{:cpu}}; particles=nothing)\n\nCalculates force density of material pair particles using CPU. Calls force_density_t_ij for each pair of particles in the material. The force_density_t_ij function is defined in the specific material type.\n\nArguments\n\nf::AbstractArray: Force of the material.\ny::AbstractArray: Deformed position of the material.\nlimits::AbstractVector{Int64}: Limits of the material.\nmat::GeneralMaterial: General material type.\ndevice::Type{Val{:cpu}}: Device\nparticles::Union{Nothing, AbstractVector{Int64}}: Particles to calculate the force.\n\nReturns\n\nnothing: In-place modification of f.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_T!-Tuple{Any, Any, Any, PeridynamicsMaterial, Type{Val{:cuda}}}","page":"Autodocs","title":"PeriDyn.force_density_T!","text":"force_density_T!(f, y, limits, mat::GeneralMaterial, device::Type{Val{:cuda}}; particles=nothing)\n\nCalculates force density of material pair particles using CUDA. Calls force_density_t_ij for each pair of particles in the material. The force_density_t_ij function is defined in the specific material type.\n\nArguments\n\nf::AbstractArray: Force of the material.\ny::AbstractArray: Deformed position of the material.\nlimits::AbstractVector{Int64}: Limits of the material.\nmat::GeneralMaterial: General material type.\ndevice::Type{Val{:cuda}}: Device\nparticles::Union{Nothing, AbstractVector{Int64}}: Particles to calculate the force.\n\nReturns\n\nnothing: In-place modification of f.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_t_ij-Tuple{PeridynamicsMaterial, Vararg{Any}}","page":"Autodocs","title":"PeriDyn.force_density_t_ij","text":"force_density_t_ij(mat, args...; kwargs...)\n\nForce density function for peridynamics material. This is default implementation of force_density_t_ij function\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.init-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:SpecificMaterial, T2<:GeneralMaterial}","page":"Autodocs","title":"PeriDyn.init","text":"init(spc::T1, gen::T2) where {T1<:SpecificMaterial, T2<:GeneralMaterial}\n\nInitialize specific material type. It uses information from GeneralMaterial to create SpecificMaterial type. This is default implementation of init function which returns spc without any change.\n\nArguments\n\nspc::T1: Specific material type.\ngen::T2: General material type.\n\nReturns\n\nspc::T1: Initialized specific material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.@newmaterial-Tuple{Any, Vararg{Any}}","page":"Autodocs","title":"PeriDyn.@newmaterial","text":"newmaterial(name, fields...)\n\nCreates a new material type. The macro creates two subtypes, one for the PeridynamicsMaterial and one for the SpecificMaterial with the given name. The name of the SpecificMaterial is the given name with the suffix Specific. The name of the PeridynamicsMaterial is the given name with the suffix Material.\n\nFor example, if the name is Elastic, the macro creates two types ElasticMaterial and ElasticSpecific. The ElasticMaterial is a subtype of PeridynamicsMaterial and the ElasticSpecific is a subtype of SpecificMaterial. The ElasticSpecific type is used to store the specific parameters of the material.\n\n@newmaterial(Elastic,\n                \"young_modulus::Matrix\",\n                \"poisson_ratio::Matrix\",\n                \"density::Vector\")\n\nThe user is expected to define the force_density_t_ij function for the ElasticSpecific type.\n\nArguments\n\nname::Symbol: Name of the material.\nfields::Symbol: Fields of the specific material.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#Specific-material-models-and-functions","page":"Autodocs","title":"Specific material models and functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages = [\"skip_specific.jl\", \"bond_based.jl\", \"ordinary_state_based.jl\", \"elasto_plastic.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.SkipSpecific","page":"Autodocs","title":"PeriDyn.SkipSpecific","text":"SkipSpecific <: SpecificMaterial\n\nSkip specific material type.\n\nFields\n\ndensity::AbstractArray{<:QF, 1}: Density.\ncritical_stretch::AbstractArray{Float64, 2}: Critical stretch.\n\nReturns\n\nSkipSpecific: Skip specific material.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.BondBasedMaterial","page":"Autodocs","title":"PeriDyn.BondBasedMaterial","text":"BondBasedMaterial <: PeridynamicsMaterial\n\nBond based material type.\n\nFields\n\nname::String: Name of material.\ntype::Array: Type of material particles.\nbid::Int: Material block id.\ngeneral::GeneralMaterial: General material type.\nspecific::BondBasedSpecific: Bond based specific material type.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.BondBasedSpecific","page":"Autodocs","title":"PeriDyn.BondBasedSpecific","text":"BondBasedSpecific\n\nBond based specific material type.\n\nFields\n\nbond_stiffness::AbstractArray{T,2}: Bond stiffness matrix.\nbulk_modulus::AbstractArray{T,2}: Bulk modulus matrix.\ncritical_stretch::AbstractArray{T,2}: Critical stretch matrix.\ndensity::AbstractArray{T,1}: Density vector.\nfunc::Function: Bond force function.\n\nConstructor\n\nBondBasedSpecific(K::AbstractArray, critical_stretch::AbstractArray, density::AbstractArray; horizon=nothing, func=nothing)\nBondBasedSpecific(K::Real, critical_stretch::Real, density::Real; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.BondBasedSpecific-Tuple{AbstractMatrix{T1} where T1<:Union{Float64, Unitful.Quantity{Float64}}, AbstractMatrix, AbstractVector{T4} where T4<:Union{Float64, Unitful.Quantity{Float64}}}","page":"Autodocs","title":"PeriDyn.BondBasedSpecific","text":"BondBasedSpecific(K::Matrix, critical_stretch::Matrix, density::Vector; horizon=nothing, func=nothing)\n\nConstructs BondBasedSpecific material type.\n\nArguments\n\nK::Vector: Bulk modulus matrix.\ncritical_stretch::Vector: Critical stretch matrix.\ndensity::Vector: Density vector.\n\nKeyword Arguments\n\nhorizon::Real: Horizon.\nfunc::Function: Bond force function.\n\nReturns\n\nBondBasedSpecific: Bond based specific material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.BondBasedSpecific-Tuple{Real, Real, Real}","page":"Autodocs","title":"PeriDyn.BondBasedSpecific","text":"BondBasedSpecific(K::Real, critical_stretch::Real, density::Real; kwargs...)\n\nConstructs BondBasedSpecific material type.\n\nArguments\n\nK::Real: Bulk modulus matrix.\ncritical_stretch::Real: Critical stretch matrix.\ndensity::Real: Density vector.\n\nKeyword Arguments\n\nhorizon::Real: Horizon.\nfunc::Function: Bond force function.\n\nReturns\n\nBondBasedSpecific: Bond based specific material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.BondBasedSpecific-Tuple{Vector, Vector, Vector}","page":"Autodocs","title":"PeriDyn.BondBasedSpecific","text":"BondBasedSpecific(K::Vector, critical_stretch::Vector, density::Vector; kwargs...)\n\nConstructs BondBasedSpecific material type.\n\nArguments\n\nK::Vector: Bulk modulus matrix.\ncritical_stretch::Vector: Critical stretch matrix.\ndensity::Vector: Density vector.\n\nKeyword Arguments\n\nhorizon::Real: Horizon.\nfunc::Function: Bond force function.\n\nReturns\n\nBondBasedSpecific: Bond based specific material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-Tuple{Any, Any, Any, Any, BondBasedSpecific}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(name, type, bid, gen, spc::BondBasedSpecific)\n\nConstructs BondBasedMaterial material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.bond_force-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.bond_force","text":"bond_force(s, bond_stiffness)\n\nBond force function.\n\nArguments\n\ns::Real: Bond stretch.\nbond_stiffness::Real: Bond stiffness.\n\nReturns\n\nReal: Bond force.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_t_ij-Tuple{BondBasedMaterial, Vararg{Any, 12}}","page":"Autodocs","title":"PeriDyn.force_density_t_ij","text":"force_density_t_ij(mat::BondBasedMaterial,\n                i, j, k, type1, type2,\n                xij, yij, extension, s,\n                wij, wji, items)\n\nCalculates force density (actually acceleration) for bond based material type.\n\nArguments\n\nmat::BondBasedMaterial: Bond based material type.\ni::Int: Index of particle i.\nj::Int: Index of particle j in N_i.\nk::Int: Location index of particle j in family and intact.\ntype1::Int: Type of particle i.\ntype2::Int: Type of particle j.\nxij::Real: lVert X_ij rVert\nyij::Real: lVert Y_ij rVert\nextension::Real: Bond extension.\ns::Real: Bond stretch.\nwij::Real: Influence function (omega_ij) for pair (ij).\nwji::Real: Influence function (omega_ji) for pair (ji).\nitems::Tuple: Items for force calculation.\n\nReturns\n\nReal: Force density.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_items-Tuple{BondBasedMaterial}","page":"Autodocs","title":"PeriDyn.get_items","text":"get_items(mat::BondBasedMaterial)\n\nReturns items for force calculation.\n\nArguments\n\nmat::BondBasedMaterial: Bond based material type.\n\nReturns\n\nbond_stiffness::AbstractArray: Bond stiffness.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.init-Tuple{BondBasedSpecific, GeneralMaterial}","page":"Autodocs","title":"PeriDyn.init","text":"init(spc::BondBasedSpecific, gen::GeneralMaterial)\n\nInitializes BondBasedSpecific material type.\n\nArguments\n\nspc::BondBasedSpecific: Bond based specific material type.\ngen::GeneralMaterial: General material type.\n\nReturns\n\nBondBasedSpecific: Bond based specific material type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.out_of_loop!-Tuple{Any, BondBasedMaterial, Any}","page":"Autodocs","title":"PeriDyn.out_of_loop!","text":"out_of_loop!(y_, mat::BondBasedMaterial, device)\n\nIt is called once before the main loop for force calculation. It does nothing for BondBasedMaterial.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.OrdinaryStateBasedMaterial","page":"Autodocs","title":"PeriDyn.OrdinaryStateBasedMaterial","text":"OrdinaryStateBasedMaterial <: PeridynamicsMaterial\n\nOrdinary state based material type.\n\nFields\n\nname::String: Name of material.\ntype::Array: Type of material particles.\nbid::Int: Material block id.\ngeneral::GeneralMaterial: General material type.\nspecific::OrdinaryStateBasedSpecific: Specific material type.\n\nReturns\n\nOrdinaryStateBasedMaterial: Ordinary state based material.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.OrdinaryStateBasedSpecific","page":"Autodocs","title":"PeriDyn.OrdinaryStateBasedSpecific","text":"OrdinaryStateBasedSpecific <: SpecificMaterial\n\nOrdinary state based specific material type.\n\nFields\n\nbulk_modulus::AbstractArray{<:QF, 2}: Bulk modulus.\nshear_modulus::AbstractArray{<:QF, 2}: Shear modulus.\ncritical_stretch::AbstractArray{Float64, 2}: Critical stretch.\ndensity::AbstractArray{<:QF, 1}: Density.\ntheta::AbstractArray{<:QF, 1}: Dilatation.\n\nReturns\n\nOrdinaryStateBasedSpecific: Ordinary state based specific material.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.OrdinaryStateBasedSpecific-Tuple{AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}, AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}, AbstractVector{Float64}, AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}}","page":"Autodocs","title":"PeriDyn.OrdinaryStateBasedSpecific","text":"OrdinaryStateBasedSpecific(bulk_modulus, shear_modulus, critical_stretch, density)\n\nCreates ordinary state based specific material type.\n\nArguments\n\nbulk_modulus::AbstractVector{<:QF}: Bulk modulus.\nshear_modulus::AbstractVector{<:QF}: Shear modulus.\ncritical_stretch::AbstractVector{Float64}: Critical stretch.\ndensity::AbstractVector{<:QF}: Density.\n\nReturns\n\nOrdinaryStateBasedSpecific: Ordinary state based specific material.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-Tuple{Any, Any, Any, Any, OrdinaryStateBasedSpecific}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(name, type, bid, gen, spc::OrdinaryStateBasedSpecific)\n\nCreates ordinary state based material type.\n\nArguments\n\nname::String: Name of material.\ntype::Int: Type of material.\nbid::Int: Bond type.\ngen::GeneralMaterial: General material.\nspc::OrdinaryStateBasedSpecific: Specific material.\n\nReturns\n\nOrdinaryStateBasedMaterial: Ordinary state based material.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_t_ij-Tuple{OrdinaryStateBasedMaterial, Vararg{Any, 12}}","page":"Autodocs","title":"PeriDyn.force_density_t_ij","text":"force_density_t_ij(mat::OrdinaryStateBasedMaterial,\n                        i, j, k, type1, type2,\n                        xij, yij, extension, s,\n                        wij, wji, items)\n\nCalculates force density (actually acceleration) for ordinary state based material type.\n\nArguments\n\nmat::BondBasedMaterial: Ordinary state based material.\ni::Int: Index of particle i.\nj::Int: Index of particle j in N_i.\nk::Int: Location index of particle j in family and intact.\ntype1::Int: Type of particle i.\ntype2::Int: Type of particle j.\nxij::Real: lVert X_ij rVert\nyij::Real: lVert Y_ij rVert\nextension::Real: Bond extension.\ns::Real: Bond stretch.\nwij::Real: Influence function (omega_ij) for pair (ij).\nwji::Real: Influence function (omega_ji) for pair (ji).\nitems::Tuple: Items for force calculation.\n\nReturns\n\nReal: Force density.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_items-Tuple{OrdinaryStateBasedMaterial}","page":"Autodocs","title":"PeriDyn.get_items","text":"get_items(mat::OrdinaryStateBasedMaterial)\n\nReturns items for force calculation.\n\nArguments\n\nmat::BondBasedMaterial: Ordinary state based material.\n\nReturns\n\nTuple: Items for force calculation.\n\n(m, theta, K, G) where m is weighted volume, theta is dilatation, K is bulk modulus, G is shear modulus.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.init-Tuple{OrdinaryStateBasedSpecific, GeneralMaterial}","page":"Autodocs","title":"PeriDyn.init","text":"init(spc::OrdinaryStateBasedSpecific, gen::GeneralMaterial)\n\nInitializes ordinary state based specific material type. Set spc.theta to zero.\n\nArguments\n\nspc::OrdinaryStateBasedSpecific: Specific material.\ngen::GeneralMaterial: General material.\n\nReturns\n\nOrdinaryStateBasedSpecific: Specific material.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.out_of_loop!-Tuple{Any, OrdinaryStateBasedMaterial, Any}","page":"Autodocs","title":"PeriDyn.out_of_loop!","text":"out_of_loop!(y_, mat::OrdinaryStateBasedMaterial, device)\n\nCalculates dilatation for ordinary state based material type.\n\nArguments\n\ny_::AbstractArray: Deformed positions.\nmat::OrdinaryStateBasedMaterial: Ordinary state based material.\ndevice::Type{Val{:device}}: Device type.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.DruckerPrager","page":"Autodocs","title":"PeriDyn.DruckerPrager","text":"DruckerPrager <: PlasticFailureCriteria\n\nDrucker-Prager failure criterion.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ElastoPlasticSolidMaterial","page":"Autodocs","title":"PeriDyn.ElastoPlasticSolidMaterial","text":"ElastoPlasticSolidMaterial <: PeridynamicsMaterial\n\nElastic-plastic solid material.\n\nFields\n\nname::String: Name of the material\ntype::Array: Type of the material\nbid::Int: Block id\ngeneral::GeneralMaterial: General material\nspecific::ElastoPlasticSolidSpecific: Specific material\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ElastoPlasticSolidSpecific","page":"Autodocs","title":"PeriDyn.ElastoPlasticSolidSpecific","text":"ElasticPlasticSolidMaterial <: PeridynamicsMaterial\n\nElastic-plastic solid material.\n\nFields\n\nbulk_modulus::AbstractArray{<:QF,2}: Bulk modulus\nshear_modulus::AbstractArray{<:QF,2}: Shear modulus\ncritical_stretch::AbstractArray{Float64,2}: Critical stretch\ndensity::AbstractArray{<:QF,1}: Density\nσγ::AbstractArray{<:QF,2}: Yield stress\nψ::AbstractArray{<:QF,2}: Yield stress value\nedp::AbstractArray{<:QF,2}: Plastic deviatoric strain\ntd_norm2::AbstractArray{<:QF,1}: td_norm2\ntheta::AbstractArray{<:QF,1}: Dilatation\ncriteria::PlasticFailureCriteria: Plastic failure criteria\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ElastoPlasticSolidSpecific-Tuple{AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}, AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}, Vector{Float64}, AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}, AbstractVector{<:Union{Float64, Unitful.Quantity{Float64}}}}","page":"Autodocs","title":"PeriDyn.ElastoPlasticSolidSpecific","text":"ElastoPlasticSolidSpecific(\n    bulk_modulus::AbstractArray{<:QF,1},\n    shear_modulus::AbstractArray{<:QF,1},\n    critical_stretch::Array{Float64,1},\n    density::AbstractArray{<:QF,1},\n    σγ::AbstractArray{<:QF,1};\n    criteria = VonMises())\n\nConstruct an ElastoPlasticSolidSpecific material.\n\nArguments\n\nbulk_modulus::AbstractArray{<:QF,1}: Bulk modulus\nshear_modulus::AbstractArray{<:QF,1}: Shear modulus\ncritical_stretch::Array{Float64,1}: Critical stretch\ndensity::AbstractArray{<:QF,1}: Density\nσγ::AbstractArray{<:QF,1}: Yield stress\ncriteria::PlasticFailureCriteria: Plastic failure criteria\n\nReturns\n\nspc::ElastoPlasticSolidSpecific: Specific material\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.MohrCoulomb","page":"Autodocs","title":"PeriDyn.MohrCoulomb","text":"MohrCoulomb <: PlasticFailureCriteria\n\nMohr-Coulomb failure criterion.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.PeridynamicsMaterial-Tuple{Any, Any, Any, Any, ElastoPlasticSolidSpecific}","page":"Autodocs","title":"PeriDyn.PeridynamicsMaterial","text":"PeridynamicsMaterial(name, type, bid, gen, spc::ElastoPlasticSolidSpecific)\n\nConstruct an ElastoPlasticSolidMaterial.\n\nArguments\n\nname::String: Name of the material\ntype::Array: Type of the material\nbid::Int: Block id\ngen::GeneralMaterial: General material\nspc::ElastoPlasticSolidSpecific: Specific material\n\nReturns\n\nmat::ElastoPlasticSolidMaterial: Material\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.PlasticFailureCriteria","page":"Autodocs","title":"PeriDyn.PlasticFailureCriteria","text":"PlasticFailureCriteria\n\nAbstract type for plastic failure criteria.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.Tresca","page":"Autodocs","title":"PeriDyn.Tresca","text":"Tresca <: PlasticFailureCriteria\n\nTresca failure criterion.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.VonMises","page":"Autodocs","title":"PeriDyn.VonMises","text":"VonMises <: PlasticFailureCriteria\n\nVon Mises failure criterion.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.effective_stress2-Tuple{Any, Any, Any, VonMises}","page":"Autodocs","title":"PeriDyn.effective_stress2","text":"effective_stress2(σ₁, σ₂, σ₃, criteria::VonMises)\n\nCalculate the effective stress for Von Mises failure criterion.\n\nσₑ^2 = ((σ₁ - σ₂)^2 + (σ₂ - σ₃)^2 + (σ₁ - σ₃)^2)  2\n\nArguments\n\nσ₁::Real: First principal stress.\nσ₂::Real: Second principal stress.\nσ₃::Real: Third principal stress.\ncriteria::VonMises: Von Mises failure criterion.\n\nReturns\n\nReal: Effective stress.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.force_density_t_ij-Tuple{ElastoPlasticSolidMaterial, Vararg{Any, 12}}","page":"Autodocs","title":"PeriDyn.force_density_t_ij","text":"force_density_t_ij(mat::ElastoPlasticSolidMaterial,\n    i, j, k, type1, type2,\n    xij, yij, extension, s,\n    wij, wji, items)\n\nCalculate the force density.\n\nArguments\n\nmat::BondBasedMaterial: Bond based material type.\ni::Int: Index of particle i.\nj::Int: Index of particle j in N_i.\nk::Int: Location index of particle j in family and intact.\ntype1::Int: Type of particle i.\ntype2::Int: Type of particle j.\nxij::Real: lVert X_ij rVert\nyij::Real: lVert Y_ij rVert\nextension::Real: Bond extension.\ns::Real: Bond stretch.\nwij::Real: Influence function (omega_ij) for pair (ij).\nwji::Real: Influence function (omega_ji) for pair (ji).\nitems::Tuple: Items for force calculation.\n\nReturns\n\nReal: Force density.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_items-Tuple{ElastoPlasticSolidMaterial}","page":"Autodocs","title":"PeriDyn.get_items","text":"get_items(mat::ElastoPlasticSolidMaterial)\n\nGet the items of the material.\n\nArguments\n\nmat::ElastoPlasticSolidMaterial: Material\n\nReturns\n\nitems: Tuple of items\n\n(weighted_volume, theta, td_norm2, bulk_modulus, shear_modulus, σγ, ψ, edp, horizon, volume, criteria)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.init-Tuple{ElastoPlasticSolidSpecific, GeneralMaterial}","page":"Autodocs","title":"PeriDyn.init","text":"init(spc::ElastoPlasticSolidSpecific, gen::GeneralMaterial)\n\nInitialize the specific material. It sets the yield stress value ψ equal to 758π * sigma_e^2  delta^5 where sigma_e is the effective yield stress and delta is the horizon. It initializes the dilatation theta, the plastic deviatoric strain edp and the td_norm2 to zero.\n\nArguments\n\nspc::ElastoPlasticSolidSpecific: Specific material\ngen::GeneralMaterial: General material\n\nReturns\n\nspc::ElastoPlasticSolidSpecific: Initialized specific material\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.out_of_loop!-Tuple{Any, ElastoPlasticSolidMaterial, Any}","page":"Autodocs","title":"PeriDyn.out_of_loop!","text":"out_of_loop!(y_, mat::ElastoPlasticSolidMaterial, device)\n\nCalculate the dilatation and the td_norm2 out of the loop.\n\nArguments\n\ny_::AbstractArray{<:QF,2}: Displacement\nmat::ElastoPlasticSolidMaterial: Material\ndevice: Device\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.td_norm2_ij!-NTuple{13, Any}","page":"Autodocs","title":"PeriDyn.td_norm2_ij!","text":"td_norm2_ij!(mat, i, j, k, type1, type2,\n    xij, yij, extension, s,\n    wij, wji, items)\n\nCalculate the td_norm2.\n\nArguments\n\nmat::BondBasedMaterial: Bond based material type.\ni::Int: Index of particle i.\nj::Int: Index of particle j in N_i.\nk::Int: Location index of particle j in family and intact.\ntype1::Int: Type of particle i.\ntype2::Int: Type of particle j.\nxij::Real: lVert X_ij rVert\nyij::Real: lVert Y_ij rVert\nextension::Real: Bond extension.\ns::Real: Bond stretch.\nwij::Real: Influence function (omega_ij) for pair (ij).\nwji::Real: Influence function (omega_ji) for pair (ji).\nitems::Tuple: Items for force calculation.\n\nReturns\n\n'nothing': Update td_norm2 in-place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Contact-models-and-functions","page":"Autodocs","title":"Contact models and functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"contacts.jl\", \"nonlinearspring.jl\", \"linearspring.jl\", \"shortrange.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.ContactModel","page":"Autodocs","title":"PeriDyn.ContactModel","text":"ContactModel\n\nAbstract type for contact model.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ContactModel11","page":"Autodocs","title":"PeriDyn.ContactModel11","text":"ContactModel11\n\nAbstract type for contact model for a single material block.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ContactModel12","page":"Autodocs","title":"PeriDyn.ContactModel12","text":"ContactModel12\n\nAbstract type for contact model between two material blocks.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#Base.show-Tuple{IO, Union{ContactModel11, ContactModel12}}","page":"Autodocs","title":"Base.show","text":"Print the details of a ContactModel object.\n\nArguments\n\nio::IO: The output IO stream.\ni::Union{ContactModel11, ContactModel12}: The ContactModel object to print.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ContactModel11_gcal-NTuple{4, Any}","page":"Autodocs","title":"PeriDyn.ContactModel11_gcal","text":"ContactModel11_gcal(mat1, distanceX, max_neighs)\n\nCalculate the parameters for ContactModel11 based on the input material, distance, and maximum neighbors.\n\nArguments:\n\nmat1: The material (type ContactModel11).\ndistanceX: The distance factor.\nmax_neighs: The maximum number of neighbors.\n\nReturns a tuple containing the calculated parameters for ContactModel11.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ContactModel12_gcal-NTuple{5, Any}","page":"Autodocs","title":"PeriDyn.ContactModel12_gcal","text":"ContactModel12_gcal(mat1, mat2, distanceX, max_neighs)\n\nCalculate the parameters for ContactModel12 based on the input materials, distance, and maximum neighbors.\n\nArguments:\n\nmat1: The first material (type ContactModel11).\nmat2: The second material (type ContactModel11).\ndistanceX: The distance factor.\nmax_neighs: The maximum number of neighbors.\n\nReturns a tuple containing the calculated parameters for ContactModel12.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn._cudaconvert-Tuple{T} where T<:ContactModel11","page":"Autodocs","title":"PeriDyn._cudaconvert","text":"_cudaconvert(x::T) where T <: Union{ContactModel11,ContactModel12}\n\nConverts a single ContactModel11 or ContactModel12 object to a CUDA-compatible type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn._cudaconvert-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{ContactModel11, ContactModel12}","page":"Autodocs","title":"PeriDyn._cudaconvert","text":"_cudaconvert(x::Vector{T}) where T <: Union{ContactModel11,ContactModel12}\n\nConverts a vector of ContactModel11 or ContactModel12 objects to CUDA-compatible types.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.collision_box-Union{Tuple{T}, Tuple{AbstractArray, AbstractArray, T}} where T","page":"Autodocs","title":"PeriDyn.collision_box","text":"collision_box(x1::Array{Float64,2}, x2::Array{Float64,2}, skin::Float64)\n\nCalculates collision box between two material blocks.\n\nArguments\n\nx1: Positions of material points (block 1)\nx2: Positions of material points (block 2)\nskin: Extra distance to consider (usually >= particle size)\n\nOutput\n\nbox_min: Minimum position limits for overlap\nbox_max: Maximum position limits for overlap\nifoverlap: Boolean indicating if there is an overlap\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.short_range_contact!-Tuple{Any, Any, Any, Any, Any, Any, ContactModel11, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.short_range_contact!","text":"short_range_contact!(y, f, type, bid, vol, RM::ContactModel11, device::Type{Val{:cpu}})\n\nUpdates (inplace) the contact acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::ContactModel11: Repulsion model\ndevice::Type{Val{:cpu}}: Device type for CPU acceleration\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.short_range_contact!-Tuple{Any, Any, Any, Any, Any, Any, ContactModel11, Type{Val{:cuda}}}","page":"Autodocs","title":"PeriDyn.short_range_contact!","text":"short_range_contact!(y, f, type, bid, vol, RM::ContactModel11, device::Type{Val{:cuda}})\n\nUpdates (inplace) the contact acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::ContactModel11: Repulsion model\ndevice::Type{Val{:cuda}}: Device type for CUDA acceleration\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.short_range_contact!-Tuple{Any, Any, Any, Any, Any, Any, ContactModel11}","page":"Autodocs","title":"PeriDyn.short_range_contact!","text":"short_range_contact!(y, f, type, bid, vol, RM::ContactModel11)\n\nUpdates (inplace) the contact acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::ContactModel11: Repulsion model\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.short_range_contact!-Tuple{Any, Any, Any, Any, Any, Any, ContactModel12, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.short_range_contact!","text":"short_range_contact!(y, f, type, ContactModel)\n\nUpdates (inplace) the contact acceleration of material points.\n\nArguments\n\ny: Positions of material points.\nf: Acceleration of material points.\ntype: Type of material points.\nContactModel: Repulsion model (see contacts.jl for more details).\n\nOutput\n\nNone (Inplace update of f (acceleration)).\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.short_range_contact!-Tuple{Any, Any, Any, Any, Any, Any, ContactModel12}","page":"Autodocs","title":"PeriDyn.short_range_contact!","text":"short_range_contact!(y, f, type, bid, vol, RM::ContactModel12)\n\nUpdates (inplace) the contact acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::ContactModel12: Repulsion model\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-NTuple{8, Any}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(neighbors, x, search_distance, equi_dist, family, intact, max_part)\n\nUpdate the neighbor list for contact force calculation.\n\nArguments\n\nneighbors: Array storing the neighbor indices\nx: Positions of material points\nsearch_distance: Maximum search distance for neighbors\nequi_dist: Equilibrium distance for contact\nfamily: Array indicating the family relationship between material points\nintact: Array indicating if the family relationship is intact\nmax_part: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbors array in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-Tuple{Any, Any, ContactModel11, Symbol}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(y, type, RM::ContactModel11, device::Symbol; kwargs...)\n\nUpdate neighbor list for contact force calculation (1-1 interaction) on a specific device.\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::ContactModel11: Repulsion model\ndevice::Symbol: Device type for acceleration\nkwargs...: Additional keyword arguments\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-Tuple{Any, Any, ContactModel11, Type{Val{:cpu}}}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(y, type, RM::ContactModel11, device::Type{Val{:cpu}}; max_part=30)\n\nUpdate the neighbor list for contact force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::ContactModel11: Repulsion model for 1-1 interaction\ndevice::Type{Val{:cpu}}: Device type (CPU)\nmax_part=30: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbor list in the RM object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-Tuple{Any, Any, ContactModel11, Type{Val{:cuda}}}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(y, type, RM::ContactModel11, device::Type{Val{:cuda}}; max_part=30)\n\nUpdate neighbor list for contact force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::ContactModel11: Repulsion model for 1-1 interaction\ndevice::Type{Val{:cuda}}: Device type (CUDA)\nmax_part=30: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbor list in the RM object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-Tuple{Any, Any, ContactModel11}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(y, type, RM::ContactModel11; kwargs...)\n\nUpdate neighbor list for contact force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::ContactModel11: Repulsion model\nkwargs...: Additional keyword arguments\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_neighs!-Tuple{Any, Any, ContactModel12}","page":"Autodocs","title":"PeriDyn.update_contact_neighs!","text":"update_contact_neighs!(y, type, RM::ContactModel12; max_part=nothing)\n\nUpdate neighbor list for contact force calculation (1-2 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::ContactModel12: Repulsion model\nmax_part=nothing: Maximum number of particles (optional)\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.NonLinearSpringContactModel11","page":"Autodocs","title":"PeriDyn.NonLinearSpringContactModel11","text":"NonLinearSpringContactModel11(exponent::Float64, stifness::Float64, type::AbstractVector{Int64}, bid::Int64, material::GeneralMaterial, name::String, equi_dist::Float64, distance::Float64, neighs::AbstractArray{Int64, 2}, max_neighs::Int64)\n\nNonlinear contact model for 1-1 material blocks.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.NonLinearSpringContactModel12","page":"Autodocs","title":"PeriDyn.NonLinearSpringContactModel12","text":"NonLinearSpringContactModel12(exponent::Float64, stifness::Float64, pair::Vector{AbstractVector{Int64}}, name::String, equi_dist::Float64, distance::Float64, neighs::AbstractArray{Int64, 2}, max_neighs::Int64)\n\nNonlinear contact model for 1-2 material blocks.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.NonLinearSpringContactModel-Tuple{Any, Any, PeridynamicsMaterial, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.NonLinearSpringContactModel","text":"NonLinearSpringContactModel(exponent::Float64, stifness::Float64, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; distanceD=1.0, distanceX=3.0, max_neighs=50)\n\nConstructs a nonlinear contact model for 1-2 material blocks.\n\nArguments:\n\nexponent: The exponent for the contact force calculation.\nstifness: The stiffness coefficient for the contact force calculation.\nmat1: The first PeridynamicsMaterial.\nmat2: The second PeridynamicsMaterial.\ndistanceD: The distance factor for determining the search distance of neighbors within the same material.\ndistanceX: The distance factor for determining the search distance of neighbors between different materials.\nmax_neighs: The maximum number of neighbors to consider.\n\nReturns: A NonLinearSpringContactModel12 object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.NonLinearSpringContactModel-Tuple{Any, Any, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.NonLinearSpringContactModel","text":"NonLinearSpringContactModel(exponent::Float64, stifness::Float64, mat1::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a nonlinear contact model for 1-1 material blocks.\n\nArguments:\n\nexponent: The exponent for the contact force calculation.\nstifness: The stiffness coefficient for the contact force calculation.\nmat1: The PeridynamicsMaterial.\ndistanceX: The distance factor for determining the search distance of neighbors.\nmax_neighs: The maximum number of neighbors to consider.\n\nReturns: A NonLinearSpringContactModel11 object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_contact_force_fn-Tuple{T} where T<:Union{NonLinearSpringContactModel11, NonLinearSpringContactModel12}","page":"Autodocs","title":"PeriDyn.get_contact_force_fn","text":"get_contact_force_fn(RepMod::NonLinearSpringContactModel11)\n\nReturns a contact force function for a NonLinearSpringContactModel11 object.\n\nArguments:\n\nRepMod: The NonLinearSpringContactModel11 object.\n\nReturns: A contact force function that takes a distance vector and returns the contact acceleration.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.LinearSpringContactModel-Tuple{Any, PeridynamicsMaterial, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.LinearSpringContactModel","text":"LinearSpringContactModel(stiffness::Float64, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a linear contact model for 1-2 material blocks. The constructors internally call the NonLinearSpringContactModel constructor with a nonlinearity parameter of 1 and the provided arguments.\n\nArguments:\n\nstiffness: The stiffness coefficient for the contact model.\nmat1: PeridynamicsMaterial representing the first material block.\nmat2: PeridynamicsMaterial representing the second material block.\ndistanceX: Optional keyword argument specifying the distance parameter (default: 5).\nmax_neighs: Optional keyword argument specifying the maximum number of neighbors (default: 50).\n\nReturns:\n\nAn instance of the LinearSpringContactModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.LinearSpringContactModel-Tuple{Any, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.LinearSpringContactModel","text":"LinearSpringContactModel(stiffness::Float64, mat1::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a linear contact model for 1-1 material blocks. The constructors internally call the NonLinearSpringContactModel constructor with a nonlinearity parameter of 1 and the provided arguments.\n\nArguments:\n\nstiffness: The stiffness coefficient for the contact model.\nmat1: PeridynamicsMaterial representing the material block.\ndistanceX: Optional keyword argument specifying the distance parameter (default: 5).\nmax_neighs: Optional keyword argument specifying the maximum number of neighbors (default: 50).\n\nReturns:\n\nAn instance of the LinearSpringContactModel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ShortRangeContactModel-Tuple{Any, Any, PeridynamicsMaterial, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.ShortRangeContactModel","text":"ShortRangeContactModel(K, horizon, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; mfactor=1.0, kwargs...)\n\nCreate a short range contact model with the given stifness K and horizon horizon.\n\nArguments\n\nK: Stifness of the contact model.\nhorizon: Horizon of the contact model.\nmat1: Material of the first body.\nmat2: Material of the second body.\n\nKeyword Arguments\n\nmfactor: Multiplication factor for the stifness. Default is 1.0.\nkwargs...: Keyword arguments for the LinearSpringContactModel constructor.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ShortRangeContactModel-Tuple{Any, Any, PeridynamicsMaterial}","page":"Autodocs","title":"PeriDyn.ShortRangeContactModel","text":"ShortRangeContactModel(K, horizon, mat1::PeridynamicsMaterial; mfactor=1.0, kwargs...)\n\nCreate a short range contact model with the given stifness K and horizon horizon.\n\nArguments\n\nK: Stifness of the contact model.\nhorizon: Horizon of the contact model.\nmat1: Material of the first body.\n\nKeyword Arguments\n\nmfactor: Multiplication factor for the stifness. Default is 1.0.\nkwargs...: Keyword arguments for the LinearSpringContactModel constructor.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Boundary-conditions","page":"Autodocs","title":"Boundary conditions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"boundary_conditions.jl\", \"FixBC.jl\", \"ToFroBC.jl\", \"DeltaScaleBC.jl\", \"ScaleFixWaitBC.jl\", \"ContainerBC.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.BoundaryCondition","page":"Autodocs","title":"PeriDyn.BoundaryCondition","text":"BoundaryCondition\n\nAbstract type for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.apply_bc!-Union{Tuple{T}, Tuple{Any, T, Symbol}} where T<:BoundaryCondition","page":"Autodocs","title":"PeriDyn.apply_bc!","text":"apply_bc!(env, BC::BoundaryCondition, on::Symbol)\n\nApply the specified boundary condition BC to the given environment env on the specified aspect on.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The boundary condition to apply.\non::Symbol: The aspect on which the boundary condition is applied (:position or :velocity).\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc!-Union{Tuple{T}, Tuple{Any, T, Type{Val{:position}}}} where T<:BoundaryCondition","page":"Autodocs","title":"PeriDyn.apply_bc!","text":"apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:position}})\n\nApply the general boundary condition BC to the position aspect of the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The general boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc!-Union{Tuple{T}, Tuple{Any, T, Type{Val{:velocity}}}} where T<:BoundaryCondition","page":"Autodocs","title":"PeriDyn.apply_bc!","text":"apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:velocity}})\n\nApply the general boundary condition BC to the velocity aspect of the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The general boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Union{Tuple{T}, Tuple{Any, T}} where T<:BoundaryCondition","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::BoundaryCondition)\n\nApply the boundary condition BC to the given environment env at the start of the simulation (t=0).\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.check!-Union{Tuple{T}, Tuple{Any, T}} where T<:BoundaryCondition","page":"Autodocs","title":"PeriDyn.check!","text":"check!(env, BC::BoundaryCondition)\n\nCheck if the boundary condition BC has changed and updates the BC. Used for dynamic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.@general_bc_p-Tuple{}","page":"Autodocs","title":"PeriDyn.@general_bc_p","text":"general_bc_p()\n\nMacro for defining the common fields of a general boundary condition.\n\nThe following fields are defined:\n\nbool: Boolean array specifying the affected material points.\ndims: Boolean array specifying the affected dimensions.\nlast: Array of the same type as the state vector specifying the last state of the affected material points.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.FixBC","page":"Autodocs","title":"PeriDyn.FixBC","text":"FixBC\n\nStruct representing the FixBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\ndims: Boolean array specifying the affected dimensions.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.FixBC-Tuple{Any}","page":"Autodocs","title":"PeriDyn.FixBC","text":"FixBC(bool; onlyatstart=false)\n\nConstruct a FixBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\n\nKeyword Arguments\n\ndims: Boolean array specifying the affected dimensions (default: [true, true, true]).\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA FixBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Tuple{Any, FixBC}","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::FixBC)\n\nApply the FixBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The FixBC boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ToFroBC","page":"Autodocs","title":"PeriDyn.ToFroBC","text":"ToFroBC\n\nStruct representing the ToFroBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\ndims: Boolean array specifying the affected dimensions.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\nrate: Rate at which the elements move.\ndirection: Direction of movement.\nfreq: Frequency at which the direction of movement changes.\napplyafter: Number of steps after which the frequency is applied.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ToFroBC-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.ToFroBC","text":"ToFroBC(bool, rate, freq; applyafter=0, onlyatstart=false)\n\nConstruct a ToFroBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nrate: Rate at which the elements move.\nfreq: Frequency at which the direction of movement changes.\n\nKeyword Arguments\n\ndims: Boolean array specifying the affected dimensions (default: [true, true, true]).\napplyafter: Number of steps after which the frequency is applied (default: 0).\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA ToFroBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.MoveBC-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.MoveBC","text":"MoveBC(bool, rate; kwargs...)\n\nCreate a MoveBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nrate: Rate at which the elements move.\nkwargs: Additional keyword arguments passed to ToFroBC.\n\nReturns\n\nA MoveBC object representing the boundary condition. All MoveBC objects are ToFroBC objects with frequency Inf.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Tuple{Any, ToFroBC}","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::ToFroBC)\n\nApply the ToFroBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The ToFroBC boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.check!-Tuple{Any, ToFroBC}","page":"Autodocs","title":"PeriDyn.check!","text":"check!(BC::ToFroBC, env)\n\nPerform a check on the ToFroBC boundary condition.\n\nArguments\n\nBC: The ToFroBC boundary condition to check.\nenv: The environment associated with the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.DeltaScaleBC","page":"Autodocs","title":"PeriDyn.DeltaScaleBC","text":"DeltaScaleBC\n\nStruct representing the DeltaScaleBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\ndims: Boolean array specifying the affected dimensions.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.DeltaScaleBC-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.DeltaScaleBC","text":"DeltaScaleBC(bool, scale, fixpoint; onlyatstart=false)\n\nConstruct a DeltaScaleBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nscale: Scale factor applied to the elements.\n\nKeyword Arguments\n\ndims: Boolean array specifying the affected dimensions (default: [true, true, true]).\nfixpoint: Reference point used for scaling.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA DeltaScaleBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Tuple{Any, DeltaScaleBC}","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::DeltaScaleBC)\n\nApply the DeltaScaleBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The DeltaScaleBC boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.check!-Tuple{Any, DeltaScaleBC}","page":"Autodocs","title":"PeriDyn.check!","text":"check!(BC::DeltaScaleBC, env)\n\nPerform a check on the DeltaScaleBC boundary condition.\n\nArguments\n\nBC: The DeltaScaleBC boundary condition to check.\nenv: The environment associated with the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ScaleFixWaitBC","page":"Autodocs","title":"PeriDyn.ScaleFixWaitBC","text":"ScaleFixWaitBC\n\nStructure representing a ScaleFixWaitBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\ndims: Boolean array specifying the affected dimensions.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\ncheckF: Function for checking if the boundary condition needs to be applied.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ScaleFixWaitBC-NTuple{5, Any}","page":"Autodocs","title":"PeriDyn.ScaleFixWaitBC","text":"ScaleFixWaitBC(bool, scale, fixpoint, wait, scalebool; applyafter=0, onlyatstart=false)\n\nConstruct a ScaleFixWaitBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nscale: Scale factor for the elements.\nfixpoint: Fix point for the elements.\nwait: Number of time steps to wait before applying the condition.\nscalebool: Boolean array specifying the elements to be scaled.\n\nKeyword Arguments\n\ndims: Boolean array specifying the affected dimensions (default: [true, true, true]).\napplyafter: Number of time steps after which the condition is applied (default: 0).\nonlyatstart: Boolean indicating whether the condition is applied only at the start (default: false).\n\nReturns\n\nAn instance of ScaleFixWaitBC boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Tuple{Any, ScaleFixWaitBC}","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::ScaleFixWaitBC)\n\nApply the ScaleFixWaitBC boundary condition at time 0.\n\nArguments\n\nenv: Environment in which the condition is applied.\nBC: Instance of ScaleFixWaitBC boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.check!-Tuple{Any, ScaleFixWaitBC}","page":"Autodocs","title":"PeriDyn.check!","text":"check!(BC::ScaleFixWaitBC, env)\n\nCheck if the ScaleFixWaitBC boundary condition needs to be applied.\n\nArguments\n\nBC: Instance of ScaleFixWaitBC boundary condition.\nenv: Environment in which the condition is applied.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.ContainerBC","page":"Autodocs","title":"PeriDyn.ContainerBC","text":"ContainerBC\n\nStruct representing the ContainerBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\ndims: Boolean array specifying the affected dimensions.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.ContainerBC-Tuple{Any}","page":"Autodocs","title":"PeriDyn.ContainerBC","text":"ContainerBC(bool; limits=nothing, onlyatstart=false)\n\nConstruct a ContainerBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nlimits: Limits of the container (default: nothing).\n\nKeyword Arguments\n\ndims: Boolean array specifying the affected dimensions (default: [true, true, true]).\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA ContainerBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_bc_at0!-Tuple{Any, ContainerBC}","page":"Autodocs","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::ContainerBC)\n\nApply the ContainerBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The ContainerBC boundary condition to apply.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Solvers-and-integrators","page":"Autodocs","title":"Solvers and integrators","text":"","category":"section"},{"location":"autodocs.html#General-solver-functions","page":"Autodocs","title":"General solver functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"solvers.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.DynamicSolver","page":"Autodocs","title":"PeriDyn.DynamicSolver","text":"DynamicSolver <: Solver\n\nDynamicSolver is an abstract type for dynamic solvers.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.QuasiStaticSolver","page":"Autodocs","title":"PeriDyn.QuasiStaticSolver","text":"QuasiStaticSolver <: Solver\n\nQuasiStaticSolver is an abstract type for quasi-static solvers.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.Solver","page":"Autodocs","title":"PeriDyn.Solver","text":"Solver\n\nSolver is an abstract type for solvers.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.apply_bc_at0-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.apply_bc_at0","text":"apply_bc_at0!(env, start_at)\n\nApply boundary conditions at t = t0.\n\nArguments\n\nenv: the simulation environment.\nstart_at: Int64, the starting step.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.check_boundaries!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.check_boundaries!","text":"check_boundaries!(env)\n\nCheck if any material point is outside the defined boundaries. Do nothing.\n\nArguments\n\nenv: the simulation environment.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.run!-Tuple{Any, Int64, Solver}","page":"Autodocs","title":"PeriDyn.run!","text":"run!(envs, N::Int64, solver::Solver; filewrite_freq::Int64=10,\n    neigh_update_freq::Int64=1, average_prop_freq::Int64=1,\n    out_dir::String=\"datafile\",\n    start_at::Int64=0, write_from::Int=0, ext::Symbol=:jld,\n    max_part=30)\n\nRun simulation for a list of environments.\n\nArguments\n\nenvs: Array{Environment}, the list of environments.\nN: Int64, the number of steps.\nsolver: Solver, the solver.\n\nKeyword Arguments\n\nfilewrite_freq: Int64, the frequency of writing data files to disk. Default is 10.\nneigh_update_freq: Int64, the frequency of updating neighbors. Default is 1.\naverage_prop_freq: Int64, the frequency of calculating average properties. Default is 1.\nout_dir: String, the directory where the data files are saved. Default is \"datafile\".\nstart_at: Int64, the starting step. Default is 0.\nwrite_from: Int, the starting index of the data files. Default is 0.\next: Symbol, the extension of the data files. Default is :jld.\nmax_part: Int, the maximum number of particles in a neighborhood. Default is 30.\n\nSee also\n\nsimulate!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.simulate!-Tuple","page":"Autodocs","title":"PeriDyn.simulate!","text":"simulate!(args...; out_dir=\"datafile\", append_date=true, kwargs...)\n\nSimulate a list of environments. The last argument should be a solver. The args and kwargs are passed to run! function. The out_dir is the directory where the data files are saved. The append_date is a boolean value. If true, the date is appended to the out_dir path.\n\nSee also\n\nrun!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_acc!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.update_acc!","text":"update_acc!(env)\n\nUpdates acceleration of all the material points in a simulation environment.\n\nArguments\n\nenv: the simulation environment.\n\nSee also\n\nupdate_mat_acc! update_contact_acc! update_misc!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_contact_acc!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.update_contact_acc!","text":"update_contact_acc!(env)\n\nUpdate the forces (acceleration) due to contact.\n\nArguments\n\nenv: the simulation environment.\n\nSee also\n\nshort_range_contact!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_mat_acc!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.update_mat_acc!","text":"update_mat_acc!(env)\n\nUpdate the forces (acceleration) due to material deformation.\n\nrho ddotu(x_i t) = leftsum_j=1^N_j leftTx_i tlangle x_j-x_i rangle - Tx_j tlangle x_i-x_j rangle rightV_j + b(x_i t)right\n\nwhere T is the force density, V_j is the volume of the jth particle, rho is the density, u is the displacement, and b is the body force. The summation is over all the particles in the neighborhood given by N_j.\n\nArguments\n\nenv: the simulation environment.\n\nSee also\n\nforce_density!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_misc!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.update_misc!","text":"update_misc!(env)\n\nUpdate the misc items such as momentum etc.\n\nArguments\n\nenv: the simulation environment.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.update_neighs!-Tuple{Any}","page":"Autodocs","title":"PeriDyn.update_neighs!","text":"function update_neighs!(envs)\n\nUpdates neighbors of each material point for a list of simulation environments.\n\nArguments\n\nenvs: Array{Environment}, the list of simulation environments.\n\nSee also\n\nupdate_contact_neighs!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Quasi-static-solver","page":"Autodocs","title":"Quasi-static solver","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"minimize.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.QSDrag","page":"Autodocs","title":"PeriDyn.QSDrag","text":"QSDrag\n\nQuasi-static solver struct.\n\nFields\n\nstep_size: Float64, the step size.\ndrag: Float64, the drag coefficient.\nmax_iter: Int64, the maximum number of iterations. Default is 1000.\nx_tol: Float64, the tolerance for position. Default is 1.0e-3.\nf_tol: Float64, the tolerance for force. Default is 1.0e-3.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\n\nSee also\n\nQSDrag\napply_solver!\nminimize!\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.QSDrag-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.QSDrag","text":"QSDrag(step_size, drag; max_iter=1000, x_tol=1.0e-3, f_tol=1.0e-3)\n\nCreate a QSDrag solver.\n\nArguments\n\nstep_size: Float64, the step size.\ndrag: Float64, the drag coefficient.\n\nKeyword Arguments\n\nmax_iter: Int64, the maximum number of iterations. Default is 1000.\nx_tol: Float64, the tolerance for position. Default is 1.0e-3.\nf_tol: Float64, the tolerance for force. Default is 1.0e-3.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.apply_solver!-Tuple{Any, QSDrag}","page":"Autodocs","title":"PeriDyn.apply_solver!","text":"apply_solver!(env, solver::QSDrag)\n\nApply the QSDrag solver to the environment.\n\nArguments\n\nenv: GeneralEnvironment, the environment.\nsolver: QSDrag, the QSDrag solver.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\napply_solver!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.minimize!-Tuple{Any, QSDrag}","page":"Autodocs","title":"PeriDyn.minimize!","text":"minimize!(env, solver::QSDrag)\n\nMinimize the environment using the QSDrag solver. The QSDrag solver is a quasi-static solver that uses a drag force to minimize the energy of the system. The drag force is given by -λv(1 + k|v|), where λ is the drag coefficient and k is a constant. The constant k is set to λ/10 by default. The drag force is applied to the particles in the system, and the particles are moved by Δy = 0.5FΔt^2 + vΔt, where F is the drag force, Δt is the step size, and v is the velocity of the particles. The particles are clipped to a maximum displacement of ps/10, where ps is the particle size, and the velocity is clipped to a maximum velocity of ps/10/Δt. The solver is applied to the system until the maximum number of iterations is reached or the maximum displacement and force are below the given tolerances.\n\nArguments\n\nenv: the simulation environment.\nsolver: QSDrag, the QSDrag solver.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\nminimize!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Dynamic-solver","page":"Autodocs","title":"Dynamic solver","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"velocity_verlet.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.DSVelocityVerlet","page":"Autodocs","title":"PeriDyn.DSVelocityVerlet","text":"DSVelocityVerlet\n\nThe velocity verlet algorithm.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.apply_solver!-Tuple{Any, DSVelocityVerlet}","page":"Autodocs","title":"PeriDyn.apply_solver!","text":"apply_solver!(env, solver::DSVelocityVerlet)\n\nApply the velocity verlet algorithm to the simulation environment.\n\nArguments\n\nenv: the simulation environment.\nsolver: DSVelocityVerlet, the velocity verlet algorithm.\n\nExample\n\nsolver = DSVelocityVerlet()\napply_solver!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.velocity_verlet_step!-Tuple{Any, DSVelocityVerlet}","page":"Autodocs","title":"PeriDyn.velocity_verlet_step!","text":"velocity_verlet_step!(env, solver::DSVelocityVerlet)\n\nApply one step of the velocity verlet algorithm to the simulation environment.\n\nSteps:\n\nUpdate the velocity.\nUpdate the position.\nApply the boundary conditions to the position.\nUpdate the acceleration.\nUpdate the velocity.\nApply the boundary conditions to the velocity.\nCheck the boundary conditions.\nCheck the boundaries.\n\nArguments\n\nenv: the simulation environment.\nsolver: DSVelocityVerlet, the velocity verlet algorithm.\n\nExample\n\nsolver = DSVelocityVerlet()\nvelocity_verlet_step!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Input-and-output-functions","page":"Autodocs","title":"Input and output functions","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"io.jl\", \"ff_ovito.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.filepath_-Tuple{Any}","page":"Autodocs","title":"PeriDyn.filepath_","text":"filepath_(file_prefix::String; append_date=false)\n\nReturns the path to the output folder. If append_date is true, the date is appended.\n\nArguments\n\nfile_prefix: String, the prefix of the output folder.\n\nKeyword Arguments\n\nappend_date: Bool, the boolean value to append date to the output folder. Default is\n\nfalse.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.load_from_file-Tuple{Any}","page":"Autodocs","title":"PeriDyn.load_from_file","text":"load_from_file!(filename)\n\nLoads data from a file into the specified environment.\n\nArguments\n\nfilename: String, the name of the file to load data from.\n\nReturns\n\nenv: the simulation environment.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.print_data_file!-Tuple{Array{GeneralEnvironment}, String, Any}","page":"Autodocs","title":"PeriDyn.print_data_file!","text":"print_data_file!(envs::Array{GeneralEnvironment}, file_prefix::String, i::Int64)\n\nPrints data files to disk for a list of simulation environments.\n\nArguments\n\nenvs: Array{GeneralEnvironment}, the list of simulation environments.\nfile_prefix: String, the prefix of the output folder.\ni: Int64, the step number.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.save_state!-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.save_state!","text":"save_state!(filename, env)\n\nSave env to disk.\n\nArguments\n\nfilename: String, the filename.\nenv: GeneralEnvironment, the simulation environment.\n\nKeyword Arguments\n\nforce: Bool, the boolean value to force saving to data file format. Default is false.\n\nSee also\n\nsave_state_ovito_bc!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.save_state_ovito_bc!-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.save_state_ovito_bc!","text":"save_state_ovito_bc!(filename, env)\n\nSave env to disk for ovito visualization. The boundary conditions are saved as type.\n\nArguments\n\nfilename: String, the filename.\nenv: GeneralEnvironment, the simulation environment.\n\nKeyword Arguments\n\nforce: Bool, the boolean value to force saving to data file format. Default is false.\n\nSee also\n\nsave_state!\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.save_to_file-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.save_to_file","text":"save_to_file(env, filename)\n\nSaves data from the specified environment to a file.\n\nArguments\n\nenv: GeneralEnvironment, the environment to save.\nfilename: String, the name of the file to save data to.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.write_data-Tuple{Any}","page":"Autodocs","title":"PeriDyn.write_data","text":"write_data(filename; kwargs...)\n\nWrites the data file.\n\nArguments\n\nfilename: String, the name of the file to be written.\nkwargs: Keyword arguments, additional options for writing the file.\n\nNote: This function supports writing files in the .data and .jld2 formats.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.write_global_data-Tuple{Any}","page":"Autodocs","title":"PeriDyn.write_global_data","text":"write_global_data(filename; kwargs...)\n\nWrites the global data file.\n\nArguments\n\nfilename: String, the name of the file to be written.\nkwargs: Keyword arguments, additional options for writing the file.\n\nNote: This function writes a data file in the .jld2 format.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.jld2array-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.jld2array","text":"jld2array(file, N; start=0, step=100)\n\nLoads data from JLD files into an array.\n\nArguments\n\nfile: String, the base name of the JLD files.\nN: Int, the number of files to load.\nstart: Int, the index of the first file to load. Default is 0.\nstep: Int, the step size between files to load. Default is 100.\n\nReturns\n\nArray, an array containing the data loaded from the JLD files.\n\nNote: This function iterates over a range of files and loads data from each JLD file using the jldread function.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.jld2ovito-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.jld2ovito","text":"jld2ovito(file, N; start=0, step=100)\n\nConverts JLD files to Ovito data files.\n\nArguments\n\nfile: String, the base name of the JLD files.\nN: Int, the number of files to convert.\nstart: Int, the index of the first file to convert. Default is 0.\nstep: Int, the step size between files to convert. Default is 100.\n\nNote: This function iterates over a range of files and converts each JLD file to an Ovito data file using the write_ovito function.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.jldread-Tuple{String}","page":"Autodocs","title":"PeriDyn.jldread","text":"jldread(filename::String)\n\nReads data from a JLD file.\n\nArguments\n\nfilename: String, the name of the JLD file to read.\n\nReturns\n\nDict, a dictionary containing the data read from the JLD file.\n\nNote: This function uses the load function from the JLD package to read the data from the file, and converts it to a dictionary format.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.write_ovito-Tuple{String}","page":"Autodocs","title":"PeriDyn.write_ovito","text":"write_ovito(filename::String; kwargs...)\n\nWrites data to an Ovito data file.\n\nArguments\n\nfilename: String, the name of the file to write.\nkwargs: Keyword arguments, the data to write to the file.\n\nNote: This function writes data in Ovito data file format, with each column specified by a keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.write_ovito_cell_ids-Tuple{String, Matrix, Any}","page":"Autodocs","title":"PeriDyn.write_ovito_cell_ids","text":"write_ovito_cell_ids(filename::String, y::Matrix, horizon)\n\nWrites cell IDs to an Ovito data file.\n\nArguments\n\nfilename: String, the name of the file to write.\ny: Matrix, the coordinates of the particles.\nhorizon: The horizon value.\n\nNote: This function writes the cell IDs to an Ovito data file, based on the particle coordinates and horizon value.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Miscellaneous-functions","page":"Autodocs","title":"Miscellaneous functions","text":"","category":"section"},{"location":"autodocs.html#Logging","page":"Autodocs","title":"Logging","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"log.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.log_data-Tuple{}","page":"Autodocs","title":"PeriDyn.log_data","text":"log_data(; kwargs...)\n\nLog the data to the log file (and print).\n\nArguments\n\nkwargs: Keyword arguments, the data to be logged.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.log_detail-Tuple{Any}","page":"Autodocs","title":"PeriDyn.log_detail","text":"log_detail(x)\n\nLog a detailed information message. Prints only if the log level is 4 or higher.\n\nArguments\n\nx: String, the information message.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.log_impinfo-Tuple{Any}","page":"Autodocs","title":"PeriDyn.log_impinfo","text":"log_impinfo(x)\n\nLog an important information message. Prints only if the log level is 2 or higher.\n\nArguments\n\nx: String, the information message.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.log_info-Tuple{Any}","page":"Autodocs","title":"PeriDyn.log_info","text":"log_info(x)\n\nLog an information message.\n\nArguments\n\nx: String, the information message. Prints only if the log level is 3 or higher.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.log_warning-Tuple{Any}","page":"Autodocs","title":"PeriDyn.log_warning","text":"log_warning(x)\n\nLog a warning message. Prints only if the log level is 1 or higher.\n\nArguments\n\nx: String, the warning message.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_loglevel-Tuple{Int64}","page":"Autodocs","title":"PeriDyn.set_loglevel","text":"set_loglevel(x)\n\nSet the log level.\n\nArguments\n\nx: Int64, the log level.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.write_headers-Tuple{Any}","page":"Autodocs","title":"PeriDyn.write_headers","text":"write_headers(envs)\n\nWrite the column headers of the log file.\n\nArguments\n\nenvs: Vector{Environment}, the simulation environments.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Macros","page":"Autodocs","title":"Macros","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"const_macros.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.get_ij-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.get_ij","text":"get_ij(j, i, x)\n\nGet the difference of two vectors depending on the spatial dimensions.\n\nX_j - X_i\n\nArguments\n\nj: Int64, the index of the first vector.\ni: Int64, the index of the second vector.\nx: Matrix, the matrix of the vectors.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.get_magnitude-Tuple{Any}","page":"Autodocs","title":"PeriDyn.get_magnitude","text":"get_magnitude(a)\n\nGet the magnitude of a vector depending on the spatial dimensions.\n\nArguments\n\na: Vector, the vector.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.map_reduce-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.map_reduce","text":"map_reduce(f, op, iter; init=0.0)\n\nMap and reduce the operations to the vectors depending on the spatial dimensions.\n\nArguments\n\nf: Function, the function.\nop: Function, the operation.\niter: Any, the iterator.\n\nKeyword Arguments\n\ninit: Any, the initial value.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.refresh-Tuple{}","page":"Autodocs","title":"PeriDyn.refresh","text":"refresh()\n\nRefresh the functions which depends on macros.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.set_multi_threading-Tuple{Any}","page":"Autodocs","title":"PeriDyn.set_multi_threading","text":"set_multi_threading(x)\n\nSet the multi threading.\n\nArguments\n\nx: Bool, the multi threading.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.@_ij-Tuple{Any, Any, Any}","page":"Autodocs","title":"PeriDyn.@_ij","text":"_ij(j, i, x)\n\nGet the difference of two vectors depending on the spatial dimensions.\n\nX_j - X_i\n\nArguments\n\nj: Int64, the index of the first vector.\ni: Int64, the index of the second vector.\nx: Matrix, the matrix of the vectors.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@_magnitude-Tuple{Any}","page":"Autodocs","title":"PeriDyn.@_magnitude","text":"_magnitude(a)\n\nGet the magnitude of a vector depending on the spatial dimensions.\n\nArguments\n\na: Vector, the vector.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@applyops-Tuple{Any}","page":"Autodocs","title":"PeriDyn.@applyops","text":"applyops(x)\n\nApply the operations to the vectors depending on the spatial dimensions.\n\nArguments\n\nx: String, the operations.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@check_nan-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.@check_nan","text":"check_nan(var, name)\n\nCheck if there is nan or inf in the variable.\n\nArguments\n\nvar: Any, the variable.\nname: String, the name of the variable.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@def-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.@def","text":"def(name, defination)\n\nDefine a macro.\n\nArguments\n\nname: Symbol, the name of the macro.\ndefination: Any, the defination of the macro.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@gatherops-Tuple{Any}","page":"Autodocs","title":"PeriDyn.@gatherops","text":"gatherops(x)\n\nGather the operations to the vectors depending on the spatial dimensions.\n\nArguments\n\nx: String, the operations.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@map_reduce-NTuple{4, Any}","page":"Autodocs","title":"PeriDyn.@map_reduce","text":"map_reduce(f, op, iter, init)\n\nMap and reduce the operations to the vectors depending on the spatial dimensions.\n\nArguments\n\nf: Function, the function.\nop: Function, the operation.\niter: Any, the iterator.\ninit: Any, the initial value.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#PeriDyn.@time_code-Tuple{Any, Any}","page":"Autodocs","title":"PeriDyn.@time_code","text":"time_code(ex, name)\n\nTime the execution of the expression.\n\nArguments\n\nex: Any, the expression.\nname: String, the name of the expression.\n\n\n\n\n\n","category":"macro"},{"location":"autodocs.html#Representation","page":"Autodocs","title":"Representation","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"repr.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.DPanel-Tuple{Any}","page":"Autodocs","title":"PeriDyn.DPanel","text":"DPanel(x; title_style=\"bold blue\", title_justify=:center, kwargs...)\n\nDisplay a variable in a panel.\n\nArguments\n\nx: Any, the text to be displayed.\n\nKeyword Arguments\n\ntitle_style: String, the style of the title.\ntitle_justify: Symbol, the justification of the title.\nkwargs...: Any, keyword arguments to be passed to Panel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.SPanel-Tuple{Any}","page":"Autodocs","title":"PeriDyn.SPanel","text":"SPanel(x; title_style=\"bold green\", title_justify=:center, kwargs...)\n\nDisplay a variable in a panel.\n\nArguments\n\nx: Any, the text to be displayed.\n\nKeyword Arguments\n\ntitle_style: String, the style of the title.\ntitle_justify: Symbol, the justification of the title.\nkwargs...: Any, keyword arguments to be passed to Panel.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.array_repr-Tuple{Any}","page":"Autodocs","title":"PeriDyn.array_repr","text":"array_repr(item)\n\nRepresent an array in nice format.\n\nArguments\n\nitem: Any, the array.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.variable_color-Tuple{Any}","page":"Autodocs","title":"PeriDyn.variable_color","text":"variable_color(x; kalar=\"#773399\")\n\nColor a variable.\n\nArguments\n\nx: Any, the variable to be colored.\n\nKeyword Arguments\n\nkalar: String, the color to use.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.variable_txt-Tuple{Any}","page":"Autodocs","title":"PeriDyn.variable_txt","text":"variable_txt(item)\n\nRepresent a variable in nice format.\n\nArguments\n\nitem: Any, the variable.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#Utilities","page":"Autodocs","title":"Utilities","text":"","category":"section"},{"location":"autodocs.html","page":"Autodocs","title":"Autodocs","text":"Modules = [PeriDyn]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"autodocs.html#PeriDyn.SymMat","page":"Autodocs","title":"PeriDyn.SymMat","text":"SymMat\n\nCreate an symmetrical NxN matrix from a vector of length N(N+1)/2.\n\nArguments\n\nv::Array: Vector of length N(N+1)/2.\nN::Int: Number of layers.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"type"},{"location":"autodocs.html#PeriDyn.SymMat-Tuple{Any}","page":"Autodocs","title":"PeriDyn.SymMat","text":"SymMat\n\nCreate an symmetrical NxN matrix from a vector of length N(N+1)/2.\n\nArguments\n\nv::Array: Vector of length N(N+1)/2.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.make_NN-Tuple{T} where T","page":"Autodocs","title":"PeriDyn.make_NN","text":"make_NN(layers::T; act = Flux.relu) where {T}\n\nCreate an neural network with given layers and activation function.\n\nArguments\n\nlayers::Tuple: Tuple of layers.\n\nKeyword Arguments\n\nact::Function: Activation function.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.make_NN-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Autodocs","title":"PeriDyn.make_NN","text":"make_NN(layers::T, N; act=Flux.relu) where {T}\n\nCreate an symmetrical NxN matrix from a vector of length N(N+1)/2.\n\nArguments\n\nlayers::Tuple: Tuple of layers.\nN::Int: Number of layers.\n\nKeyword Arguments\n\nact::Function: Activation function.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.make_matrix-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Autodocs","title":"PeriDyn.make_matrix","text":"make_matrix(S::Array{T,1})\n\nCreate an symmetrical NxN matrix from a vector of length N(N+1)/2.\n\nArguments\n\nS::Array: Vector of length N(N+1)/2.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.make_matrix_gm-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Autodocs","title":"PeriDyn.make_matrix_gm","text":"make_matrix(S::Array{T,1})\n\nCreate an symmetrical NxN matrix from a vector of length N(N+1)/2.\n\nArguments\n\nS::Array: Vector of length N(N+1)/2.\n\nReturns\n\nM::Matrix: Symmetrical NxN matrix.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.make_vector-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"Autodocs","title":"PeriDyn.make_vector","text":"make_vector(M::Array{T,2})\n\nCreate an array of upper triangle of an symmetrical NxN matrix.\n\nArguments\n\nM::Matrix: Symmetrical NxN matrix.\n\nReturns\n\nS::Array: Vector of length N(N+1)/2.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.perturb-Tuple{AbstractArray}","page":"Autodocs","title":"PeriDyn.perturb","text":"perturb(x::AbstractArray; e=1.0e-6)\n\nPerturb an array with Gaussian noise.\n\nArguments\n\nx::AbstractArray: Array to be perturbed.\n\nKeyword Arguments\n\ne::Float64: Standard deviation of the Gaussian noise.\n\nReturns\n\nx::AbstractArray: Perturbed array.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.perturb-Tuple{Int64, Int64}","page":"Autodocs","title":"PeriDyn.perturb","text":"perturb(i::Int64, j::Int64; e=1.0e-6)\n\nCreate a Matrix of size i x j with Gaussian noise.\n\nArguments\n\ni::Int64: Number of rows.\nj::Int64: Number of columns.\n\nKeyword Arguments\n\ne::Float64: Standard deviation of the Gaussian noise.\n\nReturns\n\nx::AbstractArray: Matrix of size i x j with Gaussian noise.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.repack!-Tuple{Dict, Any, Any}","page":"Autodocs","title":"PeriDyn.repack!","text":"repack!(d::Dict, keys_, vals)\n\nRepack a dictionary from its components inplace.\n\nArguments\n\nd::Dict: Dictionary to be repacked.\nkeys_: Keys of the dictionary.\nvals: Values of the dictionary.\n\nReturns\n\nd::Dict: Dictionary containing the components.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.repack-Tuple","page":"Autodocs","title":"PeriDyn.repack","text":"repack(args...; keys_ = (:x, :v, :y, :volume, :type))\n\nRepack a dictionary from its components.\n\nArguments\n\nargs...: Components to be packed.\n\nKeyword Arguments\n\nkeys_ = (:x, :v, :y, :volume, :type): Keys of the dictionary.\n\nReturns\n\nd::Dict: Dictionary containing the components.\n\n\n\n\n\n","category":"method"},{"location":"autodocs.html#PeriDyn.unpack-Tuple{Dict}","page":"Autodocs","title":"PeriDyn.unpack","text":"unpack(d::Dict)\n\nUnpack a dictionary into its components.\n\nArguments\n\nd::Dict: Dictionary to be unpacked.\n\nReturns\n\nx::Array{Float64, 1}: x coordinates.\nv::Array{Float64, 1}: v coordinates.\ny::Array{Float64, 1}: y coordinates.\nvolume::Array{Float64, 1}: Volume of the mesh.\ntype::Array{Int64, 1}: Type of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"cmodels.html#Contact-models","page":"Contact models","title":"Contact models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"In PeriDyn, there is a comprehensive set of contact models for peridynamics simulation. These contact models define the physical interactions between material particles and enable the accurate representation of contact forces and repulsion effects. In this post, we will explore the various contact models available in PeriDyn and provide an overview of the associated functions.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"The contact models offer different formulations for calculating the repulsive forces between particles based on their relative positions. They are designed to simulate contact forces and prevent particle overlap, providing flexibility in modeling different contact behaviors. Such models can be applied to prevent overlap of particles of same material block and also between particles of different material blocks. The contact models are implemented as subtypes of the ContactModel abstract type. The following contact models are defined in PeriDyn:","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"ContactModel11\nContactModel12","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"Here, ContactModel11 is a contact model that calculates the repulsive forces between particles of the same material block. ContactModel12 is a contact model that calculates the repulsive forces between particles of different material blocks.","category":"page"},{"location":"cmodels.html#Short-Range-Contact-Models","page":"Contact models","title":"Short Range Contact Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"The ShortRangeContactModel implements bond-based peridynamics forces for short-range contact interactions. It incorporates repulsive forces to ensure particles do not overlap within a specified range.","category":"page"},{"location":"cmodels.html#Simple-Spring-Models","page":"Contact models","title":"Simple Spring Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"PeriDyn also provides simple spring-like contact models that can be used in peridynamics simulations. These models describe the contact behavior between particles using spring forces based on their relative positions. The available models include:","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"NonLinearSpringContactModel\nLinearSpringContactModel","category":"page"},{"location":"cmodels.html#Functions-for-Contact-Models","page":"Contact models","title":"Functions for Contact Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"PeriDyn provides several functions that are utilized for working with contact models. These functions facilitate the implementation and calculation of repulsion forces within the contact models.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"get_contact_force_fn\nshort_range_contact!\ncollision_box\nupdate_contact_neighs!\nContactModel11_gcal\nContactModel12_gcal","category":"page"},{"location":"cmodels.html#Key-Considerations","page":"Contact models","title":"Key Considerations","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"Neighbour Search: To efficiently compute contact forces, contact models need to determine which material points are in contact. This is typically done using a neighbour search algorithm. The package includes functions like update_contact_neighs! that handle neighbour list updates for contact interactions.\nCollision Detection: Before calculating contact forces, the code often performs collision detection to determine if material blocks are potentially overlapping. This can be observed in functions like collision_box, which defines a bounding box around material points to check for overlap.","category":"page"},{"location":"toc.html#Table-of-contents","page":"Table of contents","title":"Table of contents","text":"","category":"section"},{"location":"toc.html","page":"Table of contents","title":"Table of contents","text":"Pages = [\n            \"examples.md\",\n            \"materialgeometry.md\",\n            \"mmodels.md\",\n            \"cmodels.md\",\n            \"bc.md\",\n            \"solvers.md\",\n            \"io.md\",\n            \"list.md\",\n            \"autodocs.md\"\n        ]\nDepth = 3","category":"page"},{"location":"solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Here's a breakdown of the solvers implemented in the package:","category":"page"},{"location":"solvers.html#Solvers-in-PeriDyn","page":"Solvers","title":"Solvers in PeriDyn","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The package implements two primary types of solvers (Solver): quasi-static solvers and dynamic solvers. ","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Quasi-static solvers aim to find the equilibrium state of a system by gradually minimizing forces and energy. \nDynamic solvers, on the other hand, explicitly compute the time evolution of a system based on forces, velocities, and accelerations. ","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The choice of solver depends on the specific phenomenon you're simulating and the desired level of accuracy versus computational expense.","category":"page"},{"location":"solvers.html#1.-Dynamic-Solvers","page":"Solvers","title":"1. Dynamic Solvers","text":"","category":"section"},{"location":"solvers.html#**[DSVelocityVerlet](@ref):**","page":"Solvers","title":"DSVelocityVerlet:","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"This solver implements the velocity Verlet algorithm, a numerical integration method commonly used in molecular dynamics and peridynamics simulations. It offers a good balance between accuracy and computational efficiency.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Implementation Details:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The DSVelocityVerlet solver's implementation follows these steps within each time step:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Half-Step Velocity Update:  Calculate the velocity at the half-time step (t + Δt/2) using the acceleration at the current time step (t):    v(t + Δt/2) = v(t) + (Δt/2) * a(t)\nPosition Update: Update the particle positions using the calculated half-step velocities:    x(t + Δt) = x(t) + Δt * v(t + Δt/2)\nApply Boundary Conditions to Positions: Enforce any defined boundary conditions that constrain particle positions.\nAcceleration Update: Calculate the acceleration at the new time step (t + Δt) based on the updated positions and the peridynamic force calculations:    a(t + Δt) = F(x(t + Δt)) / m \nVelocity Update:  Calculate the velocity at the new time step (t + Δt) using the acceleration at the new time step (t + Δt):  v(t + Δt) = v(t + Δt/2) + (Δt/2) * a(t + Δt) \nApply Boundary Conditions to Velocities: Enforce any defined boundary conditions that affect particle velocities.\nCheck and Update Boundary Conditions: Perform checks and updates for boundary conditions that change dynamically during the simulation (e.g., ToFroBC).\nTime Step Increment: Advance the simulation time: t = t + Δt","category":"page"},{"location":"solvers.html#2.-Quasi-static-Solvers","page":"Solvers","title":"2. Quasi-static Solvers","text":"","category":"section"},{"location":"solvers.html#**[QSDrag](@ref)**:","page":"Solvers","title":"QSDrag:","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"This solver is designed for quasi-static simulations, where the goal is to reach an equilibrium state rather than explicitly simulating dynamic behaviour. It introduces a drag force to dampen the system's motion, allowing it to settle into a stable configuration.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Implementation Details:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The QSDrag solver uses a drag force to gradually reduce kinetic energy and drive the system towards equilibrium. ","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Apply Boundary Conditions: Initially, it applies all specified boundary conditions to both position and velocity.\nIterative Minimization: The core of the QSDrag solver lies in its iterative minimization process, which continues until:\nThe maximum number of iterations (specified by max_iter) is reached, or\nBoth the maximum particle displacement and the maximum force fall below their respective tolerances (x_tol and f_tol).\nDrag Force Calculation: In each iteration, the solver calculates a drag force for each particle based on its velocity.  The drag force opposes the direction of motion, effectively slowing down the particles.\nPosition and Velocity Update: Using the calculated drag forces, the solver updates particle positions and velocities. Importantly, it limits both displacement and velocity within each step to maintain stability during the minimization process.\nBoundary Condition Checks and Updates:  After updating the system's state, the solver checks for boundary condition violations and updates the system accordingly. This step is crucial to ensure that the system converges to a state that satisfies all imposed constraints.\nTime Step Increment: Once the iteration criteria are met, the solver increments the time step.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Implementations related to solvers:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver\nQuasiStaticSolver\nQSDrag\napply_solver!(::Any, ::QSDrag)\nminimize!\nDynamicSolver\nDSVelocityVerlet\napply_solver!(::Any, ::DSVelocityVerlet)\nvelocity_verlet_step!","category":"page"},{"location":"solvers.html#Running-the-Simulation","page":"Solvers","title":"Running the Simulation","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The simulation can be run using the simulate! or run! functions.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"simulate! is a higher-level function that takes care of setting up the output directory and calling the run! function.\nrun! is the core function that executes the simulation loop.","category":"page"},{"location":"solvers.html#The-[simulate!](@ref)-Function","page":"Solvers","title":"The simulate! Function","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The simulate! function has the following signature:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"function simulate!(args...; out_dir=\"datafile\", append_date=true, kwargs...)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Arguments:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"args...: Arguments passed to the run! function.\nout_dir=\"datafile\": Directory where the data files are saved.\nappend_date=true: If true, the date is appended to the out_dir path.\nkwargs...: Keyword arguments passed to the run! function.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Usage:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"simulate!(envs, steps, solver; kwargs...)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"where:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"envs is an array of Environment (GeneralEnvironment) objects representing the simulation environments.\nsteps is the number of simulation steps to run.\nsolver is a Solver object specifying the numerical integration scheme to use.","category":"page"},{"location":"solvers.html#The-[run!](@ref)-Function","page":"Solvers","title":"The run! Function","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The run! function has the following signature:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"function run!(envs, N::Int64, solver::Solver; filewrite_freq::Int64=10,\n    neigh_update_freq::Int64=1, average_prop_freq::Int64=1,\n    out_dir::String=\"datafile\",\n    start_at::Int64=0, write_from::Int=0, ext::Symbol=:jld,\n    max_part=30)","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Arguments:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"envs: Array of Environment (GeneralEnvironment) objects representing the simulation environments.\nN: Number of simulation steps to run.\nsolver: Solver object specifying the numerical integration scheme to use.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Keyword Arguments:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"filewrite_freq::Int64=10: Frequency of writing data files to disk.\nneigh_update_freq::Int64=1: Frequency of updating neighbour lists.\naverage_prop_freq::Int64=1: Frequency of calculating average properties.\nout_dir::String=\"datafile\": Directory where the data files are saved.\nstart_at::Int64=0: Starting step.\nwrite_from::Int=0: Starting index of the data files.\next::Symbol=:jld: Extension of the data files.\nmax_part=30: kwargs for neighbour update function.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Simulation Loop:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The run! function performs the following steps in a loop:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Update Neighbour Lists: Update the neighbour lists for each Environment (GeneralEnvironment) if i % neigh_update_freq == 0, where i is the current simulation step.\nApply Solver: Apply the specified solver to each Environment (GeneralEnvironment).\nPrint Data: Write the simulation data to disk if i % filewrite_freq == 0.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"This loop continues until the specified number of steps have been completed.","category":"page"},{"location":"solvers.html#Updating-the-Simulation-State","page":"Solvers","title":"Updating the Simulation State","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"The simulation state is updated by the following functions:","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"`update_acc!`: This function updates the acceleration of all material points in a simulation environment. It calculates the acceleration due to material deformation ([]update_mat_acc!](#ref)) and contact forces (update_contact_acc!) and updates the momentum (update_misc!).\nupdate_neighs!: Updates the neighbour lists of material points for contact force calculations. This is important for efficient computation of contact forces between particles that are close to each other.\napply_bc_at0: This function applies the boundary conditions at the beginning of the simulation (start_at = 0). This sets the initial conditions for the simulation, such as fixing certain particles in place or assigning initial velocities.","category":"page"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Within the main simulation loop, these functions are called at specific frequencies determined by the neigh_update_freq and filewrite_freq parameters. For example, the neighbour lists are updated every neigh_update_freq steps. The acceleration is updated at each step of the simulation.","category":"page"},{"location":"mmodels.html#Material-Models","page":"Material models","title":"Material Models","text":"","category":"section"},{"location":"mmodels.html#Material-models-in-PeriDyn","page":"Material models","title":"Material models in PeriDyn","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"A peridynamics material model in PeriDyn is defined using two key components: a general material model (GeneralMaterial) and a specific material model.  This approach separates the fundamental geometric and discretization data of a material from its constitutive behaviour.","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The general material model (GeneralMaterial) stores information that dictates how a material is structurally represented within the simulation environment. This encompasses:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Particle Data: This includes the positions (x, y), velocities (velocity), and volumes (volume) of individual particles that constitute the material. The deformed positions (y) can be initialised independently, allowing the simulation to start from a pre-deformed state.\nMaterial Type and Block ID: Each particle is associated with a type (type) and a block ID (bid).  The type distinguishes different materials within a simulation containing multiple materials, while the bid identifies particles belonging to the same material block.\nDiscretization Parameters: The general model stores the particle size (particle_size) and the horizon (horizon). The horizon determines the range of interaction for each particle, a key aspect of peridynamic theory.\nNeighbour Information: The family array stores the indices of neighbouring particles within a particle's horizon. The intact array, a boolean array, indicates whether a bond between two particles is intact or broken based on the deformation criteria.\nWeighted Volume: The weighted_volume (represented as 'm' in some source code) is crucial for calculating internal forces.  It represents the influence of a particle's volume within its neighbourhood.","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The specific material model defines the constitutive relationship of the material—essentially, how it responds to deformation.  These models encapsulate the material's intrinsic behaviour, independent of its geometric representation. Some specific material models include: ","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"BondBasedSpecific: This model dictates material behaviour solely based on bond stretch between particle pairs. It is suitable for materials where forces arise primarily from bond elongation or compression. Key parameters include bulk modulus, critical stretch (the point at which a bond breaks), and density. The BondBasedMaterial combines this specific model with the general information to create a usable material block.\nOrdinaryStateBasedSpecific: This model incorporates both the deformation of individual bonds and the collective deformation of a particle's neighbourhood. It accounts for the influence of surrounding particles on a particle's deformation, making it suitable for a broader range of material behaviours compared to the bond-based model. This model utilizes parameters like bulk modulus, shear modulus, critical stretch, and density. Similar to the bond-based model, OrdinaryStateBasedMaterial combines the specific model (OrdinaryStateBasedSpecific) with the general material information.\nElastoPlasticSolidSpecific: This model captures the behaviour of materials that exhibit both elastic and plastic deformation. It considers parameters such as bulk modulus, shear modulus, critical stretch, density, yield stress, and a plastic failure criterion.  The ElastoPlasticSolidMaterial combines this specific model with the general material information to model a block of material.","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Each specific material model defines a force_density_t_ij function. This function calculates the force density, representing the internal forces acting on a particle due to its interaction with its neighbours, based on the specific material model used. ","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"This separation of general and specific material models in PeriDyn allows for a modular and flexible approach to defining materials. Users can easily switch between different constitutive models while keeping the geometric and discretization aspects consistent.  This facilitates the exploration of various material behaviours within the same simulation setup, simplifying comparative analyses and model development.","category":"page"},{"location":"mmodels.html#Details-of-material-models","page":"Material models","title":"Details of material models","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"PeriDyn offers a wide range of material models specifically designed for peridynamics simulations. These material models play a crucial role in defining the physical properties of material particles and ensuring accurate representation of material behavior. In this documentation, we will delve into the various material models available in PeriDyn and provide an overview of their associated functions and parameters.","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The material models in PeriDyn are implemented as subtypes of the PeridynamicsMaterial abstract type. Each material model belonging to PeridynamicsMaterial encompasses the following fields:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"name: The name assigned to the material model.\ntype: The type of material elements associated with the model.\nblockid: The block ID of the material model.\ngeneral: The general parameters of a peridynamics material model.\nspecific: The specific parameters particular to the material model.","category":"page"},{"location":"mmodels.html#General-Parameters","page":"Material models","title":"General Parameters","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The general parameters of a material model are defined using the GeneralMaterial type. The GeneralMaterial type encompasses the following parameters:","category":"page"},{"location":"mmodels.html#Arguments","page":"Material models","title":"Arguments","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"y0::AbstractArray{Float64,2}: Initial displaced position of the material points.\nv0::AbstractArray{Float64,2}: Initial velocity of the material points.\nx::AbstractArray{Float64,2}: Initial position of the material points.\nvolume::AbstractArray{Float64,1}: Volume of the material points.\ntype::AbstractArray{Int64,1}: Type of the material points.\nhorizon::Float64: Horizon of the material.","category":"page"},{"location":"mmodels.html#Keyword-Arguments","page":"Material models","title":"Keyword Arguments","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"max_neigh::Int64 = 100: Maximum number of neighbors.\nparticle_size::Float64 = 0: Particle size of the material.\nskip_bb::Bool = false: Skip bond-based material.","category":"page"},{"location":"mmodels.html#Specific-Parameters","page":"Material models","title":"Specific Parameters","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The specific parameters of a material model are defined based on the subtype of the SpecificMaterial type. PeriDyn offers several PeridynamicsMaterial models, each defined by its respective SpecificMaterial. Let's explore some of these material models:","category":"page"},{"location":"mmodels.html#SkipMaterial","page":"Material models","title":"SkipMaterial","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The SkipMaterial model is employed to bypass the material model definition for a block. Consequently, no forces will be generated in the material for a given deformation. The SkipSpecific parameters required to define this material model include:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"density: Density of the material.","category":"page"},{"location":"mmodels.html#BondBasedMaterial","page":"Material models","title":"BondBasedMaterial","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The BondBasedMaterial model is used to define material properties in bond-based peridynamics simulations. It requires the following parameters to define the BondBasedSpecific:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"bulkmodulus: Bulk modulus of the material.\ncriticalstretch: Critical stretch of the material.\ndensity: Density of the material.\nhorizon: Horizon of the material.","category":"page"},{"location":"mmodels.html#OrdinaryStateBasedMaterial","page":"Material models","title":"OrdinaryStateBasedMaterial","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The OrdinaryStateBasedMaterial model is utilized to define material properties in ordinary state-based peridynamics simulations. To define the OrdinaryStateBasedSpecific, the following parameters are required:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"bulkmodulus: Bulk modulus of the material.\nshearmodulus: Shear modulus of the material.\ncriticalstretch: Critical stretch of the material.\ndensity: Density of the material.\nhorizon: Horizon of the material.","category":"page"},{"location":"mmodels.html#ElastoPlasticSolidMaterial","page":"Material models","title":"ElastoPlasticSolidMaterial","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The ElastoPlasticSolidMaterial model is employed to define material properties in elasto-plastic peridynamics simulations. The ElastoPlasticSolidSpecific is defined using the following parameters:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"bulkmodulus: Bulk modulus of the material.\nshearmodulus: Shear modulus of the material.\ncriticalstretch: Critical stretch of the material.\ndensity: Density of the material.\nhorizon: Horizon of the material.\nyieldstress: Yield stress of the material.\ncriteria: Yield criteria of the material, such as VonMises, DruckerPrager, etc. The default is VonMises.","category":"page"},{"location":"mmodels.html#Example","page":"Material models","title":"Example","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"To create an ordinary state-based material block in PeriDyn, you need to define both the general and specific material properties and then combine them. Here's a breakdown based on the sources:","category":"page"},{"location":"mmodels.html#Defining-the-General-Material-Model-([GeneralMaterial](@ref))","page":"Material models","title":"Defining the General Material Model (GeneralMaterial)","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The general material model stores the structural and geometric information about your material block. Here's an example:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"resolution = 1.0 \nx1, v1, y1, vol1, type1 = unpack(create(Cuboid([-5 5; -5 5; -5 5]); \nresolution=resolution, type=1))\nhorizon1 = 3.0*resolution\nmat_gen1 = GeneralMaterial(y1, v1, x1, vol1, type1, horizon1, max_neigh=200)","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Explanation:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"resolution = 1.0: This line sets the discretization resolution for your material block. A lower resolution means larger particles and a coarser representation.\nx1, v1, y1, vol1, type1 = ...: This line defines the initial positions (x1), velocities (v1), deformed positions (y1), volumes (vol1), and type (type1) of the particles in the material block. The create(Cuboid(...)) function is assumed to generate these arrays based on the specified cuboid dimensions and resolution.\nhorizon1 = 3.0*resolution: This line sets the horizon for the material block.  In this example, it's three times the particle spacing (resolution).\nmat_gen1 = GeneralMaterial(...): Finally, a GeneralMaterial object (mat_gen1) is created using the information defined above. This object stores the general material properties.","category":"page"},{"location":"mmodels.html#Defining-the-Specific-Material-Model-([OrdinaryStateBasedSpecific](@ref))","page":"Material models","title":"Defining the Specific Material Model (OrdinaryStateBasedSpecific)","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"The specific material model defines the constitutive behaviour using an OrdinaryStateBasedSpecific object. Here's an example:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"K, G = 1.0, 1.0 # Bulk and Shear Modulus\ndensity1 = 1.0\ncstretch1 = 0.5 # Critical stretch\nmat_spec1 = OrdinaryStateBasedSpecific([K], [cstretch1], [density1]) ","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Explanation:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"K, G = 1.0, 1.0: This line defines the bulk modulus (K) and shear modulus (G) of the material. \ndensity1 = 1.0: This sets the density of the material.\ncstretch1 = 0.5: This line specifies the critical stretch of the material, a key parameter that governs when bonds between particles break under deformation.\nmat_spec1 = OrdinaryStateBasedSpecific(...): This line creates an OrdinaryStateBasedSpecific object, which encapsulates the specific material behaviour using the provided parameters.","category":"page"},{"location":"mmodels.html#Creating-the-Material-Block-([OrdinaryStateBasedMaterial](@ref))","page":"Material models","title":"Creating the Material Block (OrdinaryStateBasedMaterial)","text":"","category":"section"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Now that you have defined the general and specific material properties, you can create the OrdinaryStateBasedMaterial block:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"block1 = OrdinaryStateBasedMaterial(mat_gen1, mat_spec1; name=\"block 1\")","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"Explanation:","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"block1 = OrdinaryStateBasedMaterial(...): This line combines the general material model (mat_gen1) and the specific material model (mat_spec1) to create an OrdinaryStateBasedMaterial object named block1. This object represents a material block with the specified properties ready to be used in a PeriDyn simulation.","category":"page"},{"location":"mmodels.html","page":"Material models","title":"Material models","text":"This combined approach in PeriDyn provides a structured way to define materials, separating the constitutive behaviour from the geometric representation, which allows for flexibility and modularity in defining different material models.","category":"page"},{"location":"bc.html#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"Boundary conditions in PeriDyn are used to specify the behavior of material particles at the selected material location in a simulation. The page lists different types of boundary conditions that are predefined in the package.","category":"page"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"List of predefined boundary conditions:","category":"page"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"FixBC (Fix Boundary Condition)\nToFroBC (To and Fro Boundary Condition)\nMoveBC (Move Boundary Condition)\nDeltaScaleBC (Delta Scale Boundary Condition)\nScaleFixWaitBC (Scale Fix Wait Boundary Condition)","category":"page"},{"location":"bc.html#Predefined-boundary-conditions","page":"Boundary conditions","title":"Predefined boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"FixBC (Fix Boundary Condition): This boundary condition fixes the position and velocity of particles at specific boundary regions. It is typically used to simulate rigid walls or immovable boundaries. For example, it can be used to fix the position of particles at the start of the simulation to represent a fixed boundary.\nToFroBC (To and Fro Boundary Condition): This boundary condition imparts a prescribed motion to particles at specific boundary regions. It allows particles to move back and forth within a specified direction and frequency. It is useful for simulating boundaries with oscillatory motion. For instance, it can be used to simulate a boundary that moves back and forth periodically.\nMoveBC (Move Boundary Condition): This boundary condition imparts a constant velocity to particles at specific boundary regions. It is commonly used to simulate boundaries subjected to external forces or displacements. For example, it can be applied to particles at the boundary of a bar to represent a constant velocity movement.\nDeltaScaleBC (Delta Scale Boundary Condition): This boundary condition applies a scaling factor to particles at specific boundary regions. It can be used to simulate deformations or changes in the size of the material. For instance, it can be used to scale particles near a boundary to represent a stretching or compression effect.\nScaleFixWaitBC (Scale Fix Wait Boundary Condition): This boundary condition applies a scaling factor to particles after a specified number of time steps. It allows particles to be scaled or deformed over time. It can be useful for simulating time-dependent deformations. For example, it can be used to gradually apply a scaling effect to particles at the boundary after a certain waiting period.","category":"page"},{"location":"bc.html#Custom-boundary-conditions","page":"Boundary conditions","title":"Custom boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"A custom boundary condition can also be defined by the user which should be a subtype of BoundaryCondition abstract type. These boundary conditions are applied to the position and velocity aspects of the particles in the simulation defined by xF and vF functions respectively. They define the behavior of the particles at the boundaries and can be customized based on the specific requirements of the simulation. apply_bc! and apply_bc_at0! functions are used to apply the boundary conditions to the particles in the simulation. The check! function is used to check if the boundary conditions are applied correctly to the particles in the simulation. apply_bc!, apply_bc_at0! and check! functions are defined for BoundaryCondition abstract type and can be overloaded by the user to define custom boundary conditions. The default implementation of these functions is as follows.","category":"page"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"\"\"\"\n    apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:position}})\n\nApply the general boundary condition `BC` to the position aspect\nof the given environment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The general boundary condition to apply.\n\"\"\"\nfunction apply_bc!(env, BC::T, ::Type{Val{:position}}) where\n                                        T <: BoundaryCondition\n    a, b = BC.xF(env, BC)\n    env.y[:, BC.bool] .= a\n    BC.last .= b\nend\n\n\"\"\"\n    apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:velocity}})\n\nApply the general boundary condition `BC` to the velocity aspect of the\ngiven environment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The general boundary condition to apply.\n\"\"\"\nfunction apply_bc!(env, BC::T, ::Type{Val{:velocity}}) where\n                                        T <: BoundaryCondition\n    a, b = BC.vF(env, BC)\n    env.v[:, BC.bool] .= a\n    BC.last .= b\nend\n\n\"\"\"\n    apply_bc_at0!(env, BC::BoundaryCondition)\n\nApply the boundary condition `BC` to the given environment `env` at the\nstart of the simulation (t=0).\n\"\"\"\nfunction apply_bc_at0!(env, BC::T) where T <: BoundaryCondition\n    # error(\"check! method Not implemented for $(T)\")\n    log_detail(\"apply_bc_at0! method not implemented for $(T)\")\nend\n\n\"\"\"\n    check!(env, BC::BoundaryCondition)\n\nCheck if the boundary condition `BC` has changed and updates the `BC`.\nUsed for dynamic boundary conditions.\n\"\"\"\nfunction check!(env, BC::T) where T <: BoundaryCondition\n    # error(\"check! method Not implemented for $(T)\")\n    log_detail(\"check! method not implemented for $(T)\")\nend\n","category":"page"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"The following code shows how one can define the CustomNameBC boundary condition.","category":"page"},{"location":"bc.html","page":"Boundary conditions","title":"Boundary conditions","text":"\"\"\"\nThis module contains definitions for CustomNameBC boundary conditions.\n\"\"\"\n\nexport CustomNameBC\n\n\"\"\"\n    CustomNameBC\n\nStruct representing the CustomNameBC boundary condition.\n\n# Fields\n- `bool`: Boolean array specifying the affected elements.\n- `last`: Last position of the affected elements.\n- `onlyatstart`: Flag indicating if the boundary condition is applied\n    only at the start.\n- `xF`: function for updating the position.\n- `vF`: function for updating the velocity.\n\"\"\"\nstruct CustomNameBC <: BoundaryCondition\n    @general_bc_p\n    # macro will expand to:\n    # bool::AbstractArray{Bool, 1}\n    # last::AbstractArray{Float64, 2}\n    # onlyatstart::Bool\n    # xF::Function\n    # vF::Function\nend\n\n\n\"\"\"\n    CustomNameBC(args...; onlyatstart=false)\n\nConstruct a CustomNameBC boundary condition.\n\n# Arguments\n- `args`: Arguments for the boundary condition.\n- `onlyatstart`: Flag indicating if the boundary condition is applied only\n    at the start (default: `false`).\n\n# Returns\nA CustomNameBC object representing the boundary condition.\n\"\"\"\nfunction CustomNameBC(args...; onlyatstart=false)\n    last = zeros(Float64, SPATIAL_DIMENSIONS_REF[], sum(bool))\n    bool = # generate bool array depending on the args passed\n    xF = (env, BC) -> begin\n                        # write logic here\n                        (a, b)  # return a and b as the new position\n                                # and BC.last position\n                    end\n    vF = (env, BC) -> begin\n                        # write logic here\n                        (a, b)  # return a and b as the new velocity\n                                # and BC.last position\n    deviceconvert(CustomNameBC(bool, last, onlyatstart, xF, vF))\nend\n\n\"\"\"\n    apply_bc_at0!(env, BC::CustomNameBC)\n\nApply the CustomNameBC boundary condition at time 0 to the given\nenvironment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The CustomNameBC boundary condition to apply.\n\"\"\"\nfunction apply_bc_at0!(env, BC::CustomNameBC)\n    # write logic here for e.g. BC.last .= env.y[:, BC.bool]\nend\n\n\"\"\"\n    check!(env, BC::CustomNameBC)\n\nCheck if the CustomNameBC boundary condition has changed and updates\nthe `CustomNameBC`. Used for dynamic boundary conditions.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The CustomNameBC boundary condition to apply.\n\"\"\"\nfunction check!(env, BC::CustomNameBC)\n    # write logic here for e.g. BC.bool .= env.y[:, 1] .> 0.5\nend","category":"page"},{"location":"materialgeometry.html","page":"Material geometry","title":"Material geometry","text":"Creating material points for a given geometry can be done using MaterialPoints.jl package. Please see the package documentation and examples.","category":"page"},{"location":"examples.html#Examples","page":"Quick start","title":"Examples","text":"","category":"section"},{"location":"examples.html#Tensile-simulation-of-a-bar","page":"Quick start","title":"Tensile simulation of a bar","text":"","category":"section"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"To simulate the tensile behavior of a bar using the PeriDyn package, you can follow these steps:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Activate the PeriDyn environment by running the following code from the PeriDyn package directory. This will activate the environment and install the required packages or install package first.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"using Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Import the PeriDyn and PDMaterialPoints packages.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"using PeriDyn\nusing PDMaterialPoints","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Create the geometry of the material block using a Cuboid shape and a specified resolution. Then create a material generator using the created geometry and resolution. In this example, we create a bar with dimensions 20x5x5 mm and a resolution of 0.5 mm.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"See Units in PeriDyn.jl for more information about units in PeriDyn.jl.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"resolution = 0.5\n\nx1, v1, y1, vol1, type1 = unpack(create(Cuboid([0 20; 0 5; 0 5]), resolution=resolution))  # mm\nmat_gen1 = GeneralMaterial(y1, v1, x1, vol1, type1, 3.0*resolution; max_neigh=200)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Define the material parameters such as Young's modulus (Es), Poisson's ratio (nu), density (den), and critical stretch (cstretch). Then create a bond-based material block using the specified material parameters:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Es = 70 # GPa\nnu = 0.15\nK = Es/3/(1-2nu)\nG = Es/2/(1+nu)\nden = 2.2 * 1000.0 # Kg/m3\ncstretch = 0.15\n\nmat_spec1 = BondBasedSpecific([K], [cstretch], [den])\n# mat_spec1 = OrdinaryStateBasedSpecific([K], [G], [cstretch], [den])\n\nblock1 = PeridynamicsMaterial(mat_gen1, mat_spec1)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Choose a solver for the simulation. In this example, we use the DSVelocityVerlet solver and set the number of steps (Steps), file write frequency (fwf), and neighbor update frequency (nuf):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"solver = DSVelocityVerlet()\nsteps, fwf, nuf = 20000, 100, 10","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Define the boundary conditions for the simulation. Here, we fix the left part of the bar (y1[1, :] .< 4.0) and move the right part of the bar (y1[1, :] .> 16.0) with a constant velocity:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"dt = 1.0e-3\nBC1 = FixBC(y1[1, :] .< 4.0)\nvel = [0.2/steps/dt, 0.0, 0.0]\nBC2 = MoveBC(y1[1, :] .> 16.0, vel)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Define a repulsive contact model. In this example, we use a LinearRepulsionModel with a spring constant (k) and the material block defined earlier (block1):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"k = 1.0\nRM1 = LinearSpringContactModel(k, block1; distanceX=3, max_neighs=200)\nRMs = [RM1]","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Create a PeriDyn environment by specifying the material blocks, repulsion models, boundary conditions, and time step (dt):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"dt = 1e-3\nenv = PeriDyn.Env(1, [block1], RMs, [BC1, BC2], dt)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Customize the PeriDyn environment by setting parameters and defining a collection function. In this example, we set the \"left\" parameter to select the left part of the bar and collect the force values in the \"Out\" dictionary:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"env.Params = Dict(:left => (env.y[1,:] .< 4))\n\nenv.Out = Dict(:Force => zeros(3, steps))\n\nenv.Collect! = function (env, step)\n    env.Out[:Force][:, step] = sum(env.f[:, env.Params[:left]], dims=2)\nend","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Run the simulation using the run! function and specify the number of steps, solver, file write frequency, output directory, and start index. Additionally, write the simulation output to a JLD file or Ovito files for visualization:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"\nout_dir = \"./output/tensile_sim_BB/$(typeof(solver))\"\nrun!([env], steps, solver;\n    filewrite_freq=fwf, neigh_update_freq=nuf, average_prop_freq=100, out_dir=out_dir, start_at=0, ext=:data)\n\nPeriDyn.write_data(\"$(out_dir)/env_Out.jld2\"; Out=env.Out)\n\nPeriDyn.jld2ovito(\"$(out_dir)/env_1_step_*.jld2\", steps; start=0, step=fwf)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"By following these steps, you can perform a tensile simulation of a bar using the PeriDyn package and visualize the results using Ovito.","category":"page"},{"location":"examples.html#Ballistic-impact-simulation","page":"Quick start","title":"Ballistic impact simulation","text":"","category":"section"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"To simulate the ballistic impact of a projectile on a plate using the PeriDyn package, you can follow these steps:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"(Image: ballistic impact simulation gif)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Activate the PeriDyn environment by running the following code from the PeriDyn package directory. This will activate the environment and install the required packages or install package first.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Import the PeriDyn and PDMaterialPoints packages.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"using PeriDyn\nusing PDMaterialPoints","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Create the geometry of the material block for plate using a Disk shape and projectile using a Cuboid shape. Then create a material generator using the created geometry and resolution. In this example, we create a plate with radius 10 mm and thickness of 5 mm and a resolution of 0.5 mm. We also create a projectile with dimensions 5x5x5 mm and a resolution of 1.0 mm.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"resolution = 1.0\nhorizon = 3.0*resolution\n\nout1 = create(Disk(15, 5), resolution=resolution)  # mm\nout2 = create(\n            move(Cuboid([-2 2; -2 2; -2 2]),\n                    by=[0, 0, 10.0]),\n            resolution=resolution,\n            type=2\n            )\nout2[:v][3, :] .= -0.1 # m/s\n\nmat_gen1 = GeneralMaterial(out1, horizon; max_neigh=200)\nmat_gen2 = GeneralMaterial(out2, horizon; max_neigh=200)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Define the material parameters such as Young's modulus (Es), Poisson's ratio (nu), density (den), and critical stretch (cstretch). Then create a bond-based material block using the specified material parameters:","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Es = 70 # GPa\nnu = 0.15\nK = Es/3/(1-2nu)\nG = Es/2/(1+nu)\nden = 2.2 * 1000.0 # Kg/m3\ncstretch = 0.05\n\nmat_spec1 = BondBasedSpecific([K], [cstretch], [den])\nmat_spec2 = BondBasedSpecific([100*K], [cstretch], [100*den])\n\n# mat_spec1 = OrdinaryStateBasedSpecific([K], [G], [cstretch], [den])\n\nblock1 = PeridynamicsMaterial(mat_gen1, mat_spec1;\n                                 name=\"Plate\")\nblock2 = PeridynamicsMaterial(mat_gen2, mat_spec2;\n                                 name=\"Projectile\")","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Choose a solver for the simulation. In this example, we use the DSVelocityVerlet solver and set the number of steps (Steps), file write frequency (fwf), and neighbor update frequency (nuf):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"solver = DSVelocityVerlet()\nsteps, fwf, nuf = 20000, 100, 10","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Define a contact model. In this example, we use a LinearSpringContactModel with a spring constant (k) and the material block defined earlier (block1):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"k = 100*18K/pi/horizon^5\nRM1 = LinearSpringContactModel(k, block1, block2; distanceX=3, max_neighs=200)\nRM2 = LinearSpringContactModel(k, block1; distanceX=3, max_neighs=200)\nRMs = [RM1, RM2]","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Create a PeriDyn environment by specifying the material blocks, repulsion models, boundary conditions, and time step (dt):","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"dt = 1e-2\nenv = PeriDyn.Env(1, [block1, block2], RMs, [], dt)","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"Run the simulation using the run! function and specify the number of steps, solver, file write frequency, output directory, and start index. Additionally, write the simulation output to a JLD file or Ovito files for visualization.","category":"page"},{"location":"examples.html","page":"Quick start","title":"Quick start","text":"out_dir = \"./output/ballistic_impact_sim/$(typeof(solver))\"\nrun!([env], steps, solver;\n    filewrite_freq=fwf, neigh_update_freq=nuf,\n    average_prop_freq=10,\n    out_dir=out_dir, start_at=0, ext=:data)","category":"page"},{"location":"list.html","page":"Index","title":"Index","text":"CurrentModule = PeriDyn","category":"page"},{"location":"list.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"list.html","page":"Index","title":"Index","text":"","category":"page"},{"location":"index.html#PeriDyn","page":"Home","title":"PeriDyn","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: diskdamage)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriDyn is a numerical simulation software designed to solve peridynamics problems. It is written in the Julia programming language, and offers a high level of flexibility and speed. PDBenchmark is built on top of the PeriDyn package, which provides a number of predefined material models and benchmark problems. This allows users to quickly set up and run simulations, and compare their results to established benchmarks.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"tip: Tip\nPlease see the post for more information about the PeriDyn.jl package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Peridynamics is a nonlocal continuum theory that can describe material failure and fracture without using the traditional concepts of stress and strain. Instead, it models a material as a collection of particles that interact through pairwise forces. These forces depend on the separation between particles, and can be used to simulate a wide range of materials, including brittle and ductile solids, fluids, and granular materials.","category":"page"},{"location":"index.html#Units-in-PeriDyn.jl","page":"Home","title":"Units in PeriDyn.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"tip: Tip\nUnits are abstract, therefore user can use any unit system as long as it is consistent. PeriDyn.jl also provide support for quantity defined using Unitful.jl package. All calculation in PeriDyn.jl is checked for dimension consistency, as a result PriDyn.jl will throw error if dimension of a quantity is not correct. Provided units are changed to default units defined in PeriDyn.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nDefault behavior for environment construction is to use no units with all the quantities, which can be changed using keyword argument units=true in Env function. The performance of the code is better when no units are used.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n            \"examples.md\",\n            \"materialgeometry.md\",\n            \"mmodels.md\",\n            \"cmodels.md\",\n            \"bc.md\",\n            \"solvers.md\",\n            \"io.md\",\n            \"list.md\",\n            \"autodocs.md\"\n        ]\nDepth = 3","category":"page"}]
}
