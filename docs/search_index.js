var documenterSearchIndex = {"docs":
[{"location":"operatorandutil.html#Operators-and-utilities","page":"Operators and utilities","title":"Operators and utilities","text":"","category":"section"},{"location":"autodocs.html","page":"-","title":"-","text":"<!– @autodocs Modules = [PeriDyn] –>","category":"page"},{"location":"cmodels.html#Contact-models","page":"Contact models","title":"Contact models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"In PeriDyn, there is a comprehensive set of contact models for peridynamics simulation. These contact models define the physical interactions between material particles and enable the accurate representation of contact forces and repulsion effects. In this post, we will explore the various contact models available in PeriDyn and provide an overview of the associated functions.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"The repulsion models offer different formulations for calculating the repulsive forces between particles based on their relative positions. They are designed to simulate contact forces and prevent particle overlap, providing flexibility in modeling different contact behaviors. Such models can be applied to prevent overlap of particles of same material block and also between particles of different material blocks. The repulsion models are implemented as subtypes of the RepulsionModel abstract type. The following repulsion models are defined in PeriDyn:","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"RepulsionModel11\nRepulsionModel12","category":"page"},{"location":"cmodels.html#PeriDyn.RepulsionModel11","page":"Contact models","title":"PeriDyn.RepulsionModel11","text":"RepulsionModel11\n\nAbstract type for repulsion model for a single material type.\n\n\n\n\n\n","category":"type"},{"location":"cmodels.html#PeriDyn.RepulsionModel12","page":"Contact models","title":"PeriDyn.RepulsionModel12","text":"RepulsionModel12\n\nAbstract type for repulsion model for two material types.\n\n\n\n\n\n","category":"type"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"Here, RepulsionModel11 is a repulsion model that calculates the repulsive forces between particles of the same material block. RepulsionModel12 is a repulsion model that calculates the repulsive forces between particles of different material blocks.","category":"page"},{"location":"cmodels.html#Short-Range-Repulsion-Models","page":"Contact models","title":"Short Range Repulsion Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"The ShortRangeRepulsionModel implements bond-based peridynamics forces for short-range repulsion interactions. It incorporates repulsive forces to ensure particles do not overlap within a specified range.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"ShortRangeRepulsionModel","category":"page"},{"location":"cmodels.html#PeriDyn.ShortRangeRepulsionModel","page":"Contact models","title":"PeriDyn.ShortRangeRepulsionModel","text":"ShortRangeRepulsionModel(spring_const::Float64, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nCreate a ShortRangeRepulsionModel for 1-2 material blocks.\n\nArguments:\n\nspring_const: Float64, the spring constant for repulsion.\nmat1: PeridynamicsMaterial, the first material block.\nmat2: PeridynamicsMaterial, the second material block.\ndistanceX: Float64, the distance factor for neighbor searching. Default is 5.\nmax_neighs: Int64, the maximum number of neighbors. Default is 50.\n\nReturns:\n\nShortRangeRepulsionModel12: The ShortRangeRepulsionModel for 1-2 material blocks.\n\n\n\n\n\nShortRangeRepulsionModel(spring_const::Float64, mat1::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nCreate a ShortRangeRepulsionModel for 1-1 material blocks.\n\nArguments:\n\nspring_const: Float64, the spring constant for repulsion.\nmat1: PeridynamicsMaterial, the material block.\ndistanceX: Float64, the distance factor for neighbor searching. Default is 5.\nmax_neighs: Int64, the maximum number of neighbors. Default is 50.\n\nReturns:\n\nShortRangeRepulsionModel11: The ShortRangeRepulsionModel for 1-1 material blocks.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#Simple-Spring-Models","page":"Contact models","title":"Simple Spring Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"PeriDyn also provides simple spring-like contact models that can be used in peridynamics simulations. These models describe the contact behavior between particles using spring forces based on their relative positions. The available models include:","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"NonLinearSpringRepulsionModel\nLinearSpringRepulsionModel","category":"page"},{"location":"cmodels.html#PeriDyn.NonLinearSpringRepulsionModel","page":"Contact models","title":"PeriDyn.NonLinearSpringRepulsionModel","text":"NonLinearSpringRepulsionModel(exponent::Float64, stifness::Float64, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; distanceD=1.0, distanceX=3.0, max_neighs=50)\n\nConstructs a nonlinear repulsive model for 1-2 material blocks.\n\nArguments:\n\nexponent: The exponent for the repulsive force calculation.\nstifness: The stiffness coefficient for the repulsive force calculation.\nmat1: The first PeridynamicsMaterial.\nmat2: The second PeridynamicsMaterial.\ndistanceD: The distance factor for determining the search distance of neighbors within the same material.\ndistanceX: The distance factor for determining the search distance of neighbors between different materials.\nmax_neighs: The maximum number of neighbors to consider.\n\nReturns: A NonLinearSpringRepulsionModel12 object.\n\n\n\n\n\nNonLinearSpringRepulsionModel(exponent::Float64, stifness::Float64, mat1::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a nonlinear repulsive model for 1-1 material blocks.\n\nArguments:\n\nexponent: The exponent for the repulsive force calculation.\nstifness: The stiffness coefficient for the repulsive force calculation.\nmat1: The PeridynamicsMaterial.\ndistanceX: The distance factor for determining the search distance of neighbors.\nmax_neighs: The maximum number of neighbors to consider.\n\nReturns: A NonLinearSpringRepulsionModel11 object.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.LinearSpringRepulsionModel","page":"Contact models","title":"PeriDyn.LinearSpringRepulsionModel","text":"LinearSpringRepulsionModel(stiffness::Float64, mat1::PeridynamicsMaterial, mat2::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a linear repulsive model for 1-2 material blocks. The constructors internally call the NonLinearSpringRepulsionModel constructor with a nonlinearity parameter of 1 and the provided arguments.\n\nArguments:\n\nstiffness: The stiffness coefficient for the repulsive model.\nmat1: PeridynamicsMaterial representing the first material block.\nmat2: PeridynamicsMaterial representing the second material block.\ndistanceX: Optional keyword argument specifying the distance parameter (default: 5).\nmax_neighs: Optional keyword argument specifying the maximum number of neighbors (default: 50).\n\nReturns:\n\nAn instance of the LinearSpringRepulsionModel.\n\n\n\n\n\nLinearSpringRepulsionModel(stiffness::Float64, mat1::PeridynamicsMaterial; distanceX=5, max_neighs=50)\n\nConstructs a linear repulsive model for 1-1 material blocks. The constructors internally call the NonLinearSpringRepulsionModel constructor with a nonlinearity parameter of 1 and the provided arguments.\n\nArguments:\n\nstiffness: The stiffness coefficient for the repulsive model.\nmat1: PeridynamicsMaterial representing the material block.\ndistanceX: Optional keyword argument specifying the distance parameter (default: 5).\nmax_neighs: Optional keyword argument specifying the maximum number of neighbors (default: 50).\n\nReturns:\n\nAn instance of the LinearSpringRepulsionModel.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#LJ-Models","page":"Contact models","title":"LJ Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"The LJRepulsionModel represents a contact model based on the repulsive part of Lennard-Jones potential.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"LJRepulsionModel","category":"page"},{"location":"cmodels.html#PeriDyn.LJRepulsionModel","page":"Contact models","title":"PeriDyn.LJRepulsionModel","text":"LJRepulsionModel(alpha::Float64,epsilon::Float64, mat1::PeridynamicsMaterial,mat2::PeridynamicsMaterial;distanceX=5,max_neighs=50)\n\nLJ repulsive model for 1-2 material blocks.\n\n\n\n\n\nLJRepulsionModel(alpha::Float64,epsilon::Float64, mat1::PeridynamicsMaterial;distanceX=5,max_neighs=50)\n\nLJ repulsive model for 1-1 material blocks.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#Functions-for-Repulsion-Models","page":"Contact models","title":"Functions for Repulsion Models","text":"","category":"section"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"PeriDyn provides several functions that are utilized for working with repulsion models. These functions facilitate the implementation and calculation of repulsion forces within the contact models.","category":"page"},{"location":"cmodels.html","page":"Contact models","title":"Contact models","text":"repulsion_force\nshort_range_repulsion!\ncollision_box\nupdate_repulsive_neighs!\nRepulsionModel11_gcal\nRepulsionModel12_gcal","category":"page"},{"location":"cmodels.html#PeriDyn.repulsion_force","page":"Contact models","title":"PeriDyn.repulsion_force","text":"repulsion_force(dr, RepMod::NonLinearSpringRepulsionModel12)\n\nCalculates the repulsive acceleration for 1-2 material block interaction.\n\nArguments:\n\ndr: The vector representing the distance between particles.\nRepMod: The NonLinearSpringRepulsionModel12 object.\n\nReturns: The repulsive acceleration as a vector.\n\n\n\n\n\nrepulsion_force(dr, RepMod::NonLinearSpringRepulsionModel11)\n\nCalculates the repulsive acceleration for 1-1 material block interaction.\n\nArguments:\n\ndr: The vector representing the distance between particles.\nRepMod: The NonLinearSpringRepulsionModel11 object.\n\nReturns: The repulsive acceleration as a vector.\n\n\n\n\n\nrepulsion_force(dr, RepMod::ShortRangeRepulsionModel12)\n\nCalculates the repulsive acceleration for 1-2 materials block interaction.\n\nArguments:\n\ndr: Vector{Float64}, the displacement vector between particles.\nRepMod: ShortRangeRepulsionModel12, the repulsion model for 1-2 material blocks.\n\nReturns:\n\nVector{Float64}: The repulsive acceleration vector.\n\n\n\n\n\nrepulsion_force(dr, RepMod::ShortRangeRepulsionModel11)\n\nCalculates the repulsive acceleration for 1-1 materials block interaction.\n\nArguments:\n\ndr: Vector{Float64}, the displacement vector between particles.\nRepMod: ShortRangeRepulsionModel11, the repulsion model for 1-1 material blocks.\n\nReturns:\n\nVector{Float64}: The repulsive acceleration vector.\n\n\n\n\n\nrepulsion_force(dr, RepMod::LJRepulsionModel12)\n\nCalculates repulsive acceleration for 1-2 materials block interaction.\n\n\n\n\n\nrepulsion_force(dr, RepMod::LJRepulsionModel11)\n\nCalculates repulsive acceleration for 1-1 materials block interaction.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.short_range_repulsion!","page":"Contact models","title":"PeriDyn.short_range_repulsion!","text":"short_range_repulsion!(y, f, type, RepulsionModel)\n\nUpdates (inplace) the repulsive acceleration of material points.\n\nArguments\n\ny: Positions of material points.\nf: Acceleration of material points.\ntype: Type of material points.\nRepulsionModel: Repulsion model (see contacts.jl for more details).\n\nOutput\n\nNone (Inplace update of f (acceleration)).\n\n\n\n\n\nshort_range_repulsion!(y, f, type, bid, vol, RM::RepulsionModel11)\n\nUpdates (inplace) the repulsive acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::RepulsionModel11: Repulsion model\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\nshort_range_repulsion!(y, f, type, bid, vol, RM::RepulsionModel11, device::Type{Val{:cuda}})\n\nUpdates (inplace) the repulsive acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::RepulsionModel11: Repulsion model\ndevice::Type{Val{:cuda}}: Device type for CUDA acceleration\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\nshort_range_repulsion!(y, f, type, bid, vol, RM::RepulsionModel11, device::Type{Val{:cpu}})\n\nUpdates (inplace) the repulsive acceleration of material points.\n\nArguments\n\ny: Positions of material points\nf: Acceleration of material points\ntype: Type of material points\nbid: BID values\nvol: Volume values\nRM::RepulsionModel11: Repulsion model\ndevice::Type{Val{:cpu}}: Device type for CPU acceleration\n\nOutput\n\nNo return value. The function updates f in place.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.collision_box","page":"Contact models","title":"PeriDyn.collision_box","text":"collision_box(x1::Array{Float64,2}, x2::Array{Float64,2}, skin::Float64)\n\nCalculates collision box between two material blocks.\n\nArguments\n\nx1: Positions of material points (block 1)\nx2: Positions of material points (block 2)\nskin: Extra distance to consider (usually >= particle size)\n\nOutput\n\nbox_min: Minimum position limits for overlap\nbox_max: Maximum position limits for overlap\nifoverlap: Boolean indicating if there is an overlap\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.update_repulsive_neighs!","page":"Contact models","title":"PeriDyn.update_repulsive_neighs!","text":"update_repulsive_neighs!(y, type, RM::RepulsionModel12; max_part=nothing)\n\nUpdate neighbor list for repulsive force calculation (1-2 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::RepulsionModel12: Repulsion model\nmax_part=nothing: Maximum number of particles (optional)\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\nupdate_repulsive_neighs!(y, type, RM::RepulsionModel11; kwargs...)\n\nUpdate neighbor list for repulsive force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::RepulsionModel11: Repulsion model\nkwargs...: Additional keyword arguments\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\nupdate_repulsive_neighs!(y, type, RM::RepulsionModel11, device::Symbol; kwargs...)\n\nUpdate neighbor list for repulsive force calculation (1-1 interaction) on a specific device.\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::RepulsionModel11: Repulsion model\ndevice::Symbol: Device type for acceleration\nkwargs...: Additional keyword arguments\n\nOutput\n\nNo return value. The function updates RM.neighs in place.\n\n\n\n\n\nupdate_repulsive_neighs!(neighbors, x, search_distance, equi_dist, family, intact, max_part)\n\nUpdate the neighbor list for repulsive force calculation.\n\nArguments\n\nneighbors: Array storing the neighbor indices\nx: Positions of material points\nsearch_distance: Maximum search distance for neighbors\nequi_dist: Equilibrium distance for repulsion\nfamily: Array indicating the family relationship between material points\nintact: Array indicating if the family relationship is intact\nmax_part: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbors array in place.\n\n\n\n\n\nupdate_repulsive_neighs!(y, type, RM::RepulsionModel11, device::Type{Val{:cpu}}; max_part=30)\n\nUpdate the neighbor list for repulsive force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::RepulsionModel11: Repulsion model for 1-1 interaction\ndevice::Type{Val{:cpu}}: Device type (CPU)\nmax_part=30: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbor list in the RM object.\n\n\n\n\n\nupdate_repulsive_neighs!(y, type, RM::RepulsionModel11, device::Type{Val{:cuda}}; max_part=30)\n\nUpdate neighbor list for repulsive force calculation (1-1 interaction).\n\nArguments\n\ny: Positions of material points\ntype: Type of material points\nRM::RepulsionModel11: Repulsion model for 1-1 interaction\ndevice::Type{Val{:cuda}}: Device type (CUDA)\nmax_part=30: Maximum number of particles in a cell\n\nOutput\n\nNo return value. The function updates the neighbor list in the RM object.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.RepulsionModel11_gcal","page":"Contact models","title":"PeriDyn.RepulsionModel11_gcal","text":"RepulsionModel11_gcal(mat1, distanceX, max_neighs)\n\nCalculate the parameters for RepulsionModel11 based on the input material, distance, and maximum neighbors.\n\nArguments:\n\nmat1: The material (type RepulsionModel11).\ndistanceX: The distance factor.\nmax_neighs: The maximum number of neighbors.\n\nReturns a tuple containing the calculated parameters for RepulsionModel11.\n\n\n\n\n\n","category":"function"},{"location":"cmodels.html#PeriDyn.RepulsionModel12_gcal","page":"Contact models","title":"PeriDyn.RepulsionModel12_gcal","text":"RepulsionModel12_gcal(mat1, mat2, distanceX, max_neighs)\n\nCalculate the parameters for RepulsionModel12 based on the input materials, distance, and maximum neighbors.\n\nArguments:\n\nmat1: The first material (type RepulsionModel11).\nmat2: The second material (type RepulsionModel11).\ndistanceX: The distance factor.\nmax_neighs: The maximum number of neighbors.\n\nReturns a tuple containing the calculated parameters for RepulsionModel12.\n\n\n\n\n\n","category":"function"},{"location":"toc.html#Table-of-contents","page":"Table of contents","title":"Table of contents","text":"","category":"section"},{"location":"toc.html","page":"Table of contents","title":"Table of contents","text":"Pages = [\n            \"index.md\",\n            \"autodocs.md\"\n        ]\nDepth = 3","category":"page"},{"location":"solvers.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"Solver\nQuasiStaticSolver\nDynamicSolver\napply_solver!","category":"page"},{"location":"solvers.html#PeriDyn.Solver","page":"Solvers","title":"PeriDyn.Solver","text":"Solver\n\nSolver is an abstract type for solvers.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#PeriDyn.QuasiStaticSolver","page":"Solvers","title":"PeriDyn.QuasiStaticSolver","text":"QuasiStaticSolver <: Solver\n\nQuasiStaticSolver is an abstract type for quasi-static solvers.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#PeriDyn.DynamicSolver","page":"Solvers","title":"PeriDyn.DynamicSolver","text":"DynamicSolver <: Solver\n\nDynamicSolver is an abstract type for dynamic solvers.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#PeriDyn.apply_solver!","page":"Solvers","title":"PeriDyn.apply_solver!","text":"apply_solver!(env, solver::DSVelocityVerlet)\n\nApply the velocity verlet algorithm to the environment.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: DSVelocityVerlet, the velocity verlet algorithm.\n\nExample\n\nsolver = DSVelocityVerlet()\napply_solver!(env, solver)\n\n\n\n\n\napply_solver!(env, solver::QSDrag)\n\nApply the QSDrag solver to the environment.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: QSDrag, the QSDrag solver.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\napply_solver!(env, solver)\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#QuasiStaticSolver","page":"Solvers","title":"QuasiStaticSolver","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"QSDrag\napply_solver!(env, solver::QSDrag)\nminimize!","category":"page"},{"location":"solvers.html#PeriDyn.QSDrag","page":"Solvers","title":"PeriDyn.QSDrag","text":"QSDrag\n\nQuasi-static solver struct.\n\nFields\n\nstep_size: Float64, the step size.\ndrag: Float64, the drag coefficient.\nmax_iter: Int64, the maximum number of iterations. Default is 1000.\nx_tol: Float64, the tolerance for position. Default is 1.0e-3.\nf_tol: Float64, the tolerance for force. Default is 1.0e-3.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\n\nSee also\n\nQSDrag\napply_solver!\nminimize!\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#PeriDyn.apply_solver!-Tuple{Any, QSDrag}","page":"Solvers","title":"PeriDyn.apply_solver!","text":"apply_solver!(env, solver::QSDrag)\n\nApply the QSDrag solver to the environment.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: QSDrag, the QSDrag solver.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\napply_solver!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"solvers.html#PeriDyn.minimize!","page":"Solvers","title":"PeriDyn.minimize!","text":"minimize!(env, solver::QSDrag)\n\nMinimize the environment using the QSDrag solver.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: QSDrag, the QSDrag solver.\n\nExample\n\nsolver = QSDrag(1.0e-3, 1.0e-3)\nminimize!(env, solver)\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#DynamicSolver","page":"Solvers","title":"DynamicSolver","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"DSVelocityVerlet\napply_solver!(env, solver::DSVelocityVerlet)\nvelocity_verlet_step!","category":"page"},{"location":"solvers.html#PeriDyn.DSVelocityVerlet","page":"Solvers","title":"PeriDyn.DSVelocityVerlet","text":"DSVelocityVerlet\n\nThe velocity verlet algorithm.\n\n\n\n\n\n","category":"type"},{"location":"solvers.html#PeriDyn.apply_solver!-Tuple{Any, DSVelocityVerlet}","page":"Solvers","title":"PeriDyn.apply_solver!","text":"apply_solver!(env, solver::DSVelocityVerlet)\n\nApply the velocity verlet algorithm to the environment.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: DSVelocityVerlet, the velocity verlet algorithm.\n\nExample\n\nsolver = DSVelocityVerlet()\napply_solver!(env, solver)\n\n\n\n\n\n","category":"method"},{"location":"solvers.html#PeriDyn.velocity_verlet_step!","page":"Solvers","title":"PeriDyn.velocity_verlet_step!","text":"velocity_verlet_step!(env, solver::DSVelocityVerlet)\n\nApply one step of the velocity verlet algorithm to the environment.\n\nArguments\n\nenv: GeneralEnv, the environment.\nsolver: DSVelocityVerlet, the velocity verlet algorithm.\n\nExample\n\nsolver = DSVelocityVerlet()\nvelocity_verlet_step!(env, solver)\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#Running-the-simulation","page":"Solvers","title":"Running the simulation","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"simulate!\nrun!","category":"page"},{"location":"solvers.html#PeriDyn.simulate!","page":"Solvers","title":"PeriDyn.simulate!","text":"simulate!(args...; out_dir=\"datafile\", append_date=true, kwargs...)\n\nSimulate a list of environments. The last argument should be a solver. The args and kwargs are passed to run! function. The out_dir is the directory where the data files are saved. The append_date is a boolean value. If true, the date is appended to the out_dir path.\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.run!","page":"Solvers","title":"PeriDyn.run!","text":"run!(envs, N::Int64, solver::Solver; filewrite_freq::Int64=10,\n    neigh_update_freq::Int64=1, average_prop_freq::Int64=1,\n    out_dir::String=\"datafile\",\n    start_at::Int64=0, write_from::Int=0, ext::Symbol=:jld,\n    max_part=30)\n\nRun simulation for a list of environments.\n\nArguments\n\nenvs: Array{GeneralEnv}, the list of environments.\nN: Int64, the number of steps.\nsolver: Solver, the solver.\n\nKeyword Arguments\n\nfilewrite_freq: Int64, the frequency of writing data files to disk. Default is 10.\nneigh_update_freq: Int64, the frequency of updating neighbors. Default is 1.\naverage_prop_freq: Int64, the frequency of calculating average properties. Default is 1.\nout_dir: String, the directory where the data files are saved. Default is \"datafile\".\nstart_at: Int64, the starting step. Default is 0.\nwrite_from: Int, the starting index of the data files. Default is 0.\next: Symbol, the extension of the data files. Default is :jld.\nmax_part: Int, the maximum number of particles in a neighborhood. Default is 30.\n\nSee also\n\nsimulate!\n\n\n\n\n\n","category":"function"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"update_acc!\nupdate_neighs!\napply_bc_at0","category":"page"},{"location":"solvers.html#PeriDyn.update_acc!","page":"Solvers","title":"PeriDyn.update_acc!","text":"update_acc!(env::GeneralEnv)\n\nUpdates acceleration of all the material points in a simulation environment.\n\n̈u(xᵢ, t) = forces due to material deformation + forces due to contact\n\nforces due to material deformation:     > ̈u(xᵢ, t) = [∑ᵏⱼ₌₁ {T[xᵢ, t]<xⱼ-xᵢ> - T[xⱼ, t]<xᵢ-xⱼ> }*Vⱼ + b(xᵢ, t)] / ρᵢ\n\nArguments\n\nenv: GeneralEnv, the simulation environment.\n\nSee also\n\nforce_density\nshort_range_repulsion!\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.update_neighs!","page":"Solvers","title":"PeriDyn.update_neighs!","text":"function update_neighs!(envs)\n\nUpdates neighbors of each material point for a list of simulation environments.\n\nArguments\n\nenvs: Array{GeneralEnv}, the list of simulation environments.\n\nSee also\n\nupdate_repulsive_neighs!\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.apply_bc_at0","page":"Solvers","title":"PeriDyn.apply_bc_at0","text":"apply_bc_at0!(env, start_at)\n\nApply boundary conditions at t = t0.\n\nArguments\n\nenv: GeneralEnv, the simulation environment.\nstart_at: Int64, the starting step.\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#Saving-the-simulation-state","page":"Solvers","title":"Saving the simulation state","text":"","category":"section"},{"location":"solvers.html","page":"Solvers","title":"Solvers","text":"filepath_\nsave_state!\nsave_state_ovito_bc!\nprint_data_file!","category":"page"},{"location":"solvers.html#PeriDyn.filepath_","page":"Solvers","title":"PeriDyn.filepath_","text":"filepath_(file_prefix::String; append_date=false)\n\nReturns the path to the output folder. If append_date is true, the date is appended.\n\nArguments\n\nfile_prefix: String, the prefix of the output folder.\n\nKeyword Arguments\n\nappend_date: Bool, the boolean value to append date to the output folder. Default is\n\nfalse.\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.save_state!","page":"Solvers","title":"PeriDyn.save_state!","text":"save_state!(filename, env)\n\nSave env::GeneralEnv to disk.\n\nArguments\n\nfilename: String, the filename.\nenv: GeneralEnv, the simulation environment.\n\nSee also\n\nsave_state_ovito_bc!\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.save_state_ovito_bc!","page":"Solvers","title":"PeriDyn.save_state_ovito_bc!","text":"save_state_ovito_bc!(filename, env)\n\nSave env::GeneralEnv to disk for ovito visualization. The boundary conditions are saved as type.\n\nArguments\n\nfilename: String, the filename.\nenv: GeneralEnv, the simulation environment.\n\nSee also\n\nsave_state!\n\n\n\n\n\n","category":"function"},{"location":"solvers.html#PeriDyn.print_data_file!","page":"Solvers","title":"PeriDyn.print_data_file!","text":"print_data_file!(envs::Array{GeneralEnv}, file_prefix::String, i::Int64)\n\nPrints data files to disk for a list of simulation environments.\n\nArguments\n\nenvs: Array{GeneralEnv}, the list of simulation environments.\nfile_prefix: String, the prefix of the output folder.\ni: Int64, the step number.\n\n\n\n\n\n","category":"function"},{"location":"mmodels.html#Material-models","page":"Material models","title":"Material models","text":"","category":"section"},{"location":"bc.html#Boundary-conditions","page":"Boundary Conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"Boundary conditions in PeriDyn are used to specify the behavior of material particles at the selected material location in a simulation. The page lists different types of boundary conditions that are predefined in the package.","category":"page"},{"location":"bc.html#Predefined-boundary-conditions","page":"Boundary Conditions","title":"Predefined boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"FixBC (Fix Boundary Condition): This boundary condition fixes the position and velocity of particles at specific boundary regions. It is typically used to simulate rigid walls or immovable boundaries. For example, it can be used to fix the position of particles at the start of the simulation to represent a fixed boundary.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"FixBC\nFixBC(bool; onlyatstart=false)","category":"page"},{"location":"bc.html#PeriDyn.FixBC","page":"Boundary Conditions","title":"PeriDyn.FixBC","text":"FixBC\n\nStruct representing the FixBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"type"},{"location":"bc.html#PeriDyn.FixBC-Tuple{Any}","page":"Boundary Conditions","title":"PeriDyn.FixBC","text":"FixBC(bool; onlyatstart=false)\n\nConstruct a FixBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA FixBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"ToFroBC (To and Fro Boundary Condition): This boundary condition imparts a prescribed motion to particles at specific boundary regions. It allows particles to move back and forth within a specified direction and frequency. It is useful for simulating boundaries with oscillatory motion. For instance, it can be used to simulate a boundary that moves back and forth periodically.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"ToFroBC\nToFroBC(bool, rate, freq; applyafter=0, onlyatstart=false)","category":"page"},{"location":"bc.html#PeriDyn.ToFroBC","page":"Boundary Conditions","title":"PeriDyn.ToFroBC","text":"ToFroBC\n\nStruct representing the ToFroBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\ndirection: Direction of movement.\nfreq: Frequency at which the direction of movement changes.\napplyafter: Number of steps after which the frequency is applied.\n\n\n\n\n\n","category":"type"},{"location":"bc.html#PeriDyn.ToFroBC-Tuple{Any, Any, Any}","page":"Boundary Conditions","title":"PeriDyn.ToFroBC","text":"ToFroBC(bool, rate, freq; applyafter=0, onlyatstart=false)\n\nConstruct a ToFroBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nrate: Rate at which the elements move.\nfreq: Frequency at which the direction of movement changes.\napplyafter: Number of steps after which the frequency is applied (default: 0).\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA ToFroBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"MoveBC (Move Boundary Condition): This boundary condition imparts a constant velocity to particles at specific boundary regions. It is commonly used to simulate boundaries subjected to external forces or displacements. For example, it can be applied to particles at the boundary of a bar to represent a constant velocity movement.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"MoveBC","category":"page"},{"location":"bc.html#PeriDyn.MoveBC","page":"Boundary Conditions","title":"PeriDyn.MoveBC","text":"MoveBC(bool, rate; kwargs...)\n\nCreate a MoveBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nrate: Rate at which the elements move.\nkwargs: Additional keyword arguments passed to ToFroBC.\n\nReturns\n\nA MoveBC object representing the boundary condition. All MoveBC objects are ToFroBC objects with frequency Inf.\n\n\n\n\n\n","category":"function"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"DeltaScaleBC (Delta Scale Boundary Condition): This boundary condition applies a scaling factor to particles at specific boundary regions. It can be used to simulate deformations or changes in the size of the material. For instance, it can be used to scale particles near a boundary to represent a stretching or compression effect.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"DeltaScaleBC\nDeltaScaleBC(bool, scale, fixpoint; onlyatstart=false)","category":"page"},{"location":"bc.html#PeriDyn.DeltaScaleBC","page":"Boundary Conditions","title":"PeriDyn.DeltaScaleBC","text":"DeltaScaleBC\n\nStruct representing the DeltaScaleBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\n\n\n\n\n\n","category":"type"},{"location":"bc.html#PeriDyn.DeltaScaleBC-Tuple{Any, Any, Any}","page":"Boundary Conditions","title":"PeriDyn.DeltaScaleBC","text":"DeltaScaleBC(bool, scale, fixpoint; onlyatstart=false)\n\nConstruct a DeltaScaleBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nscale: Scale factor applied to the elements.\nfixpoint: Reference point used for scaling.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start (default: false).\n\nReturns\n\nA DeltaScaleBC object representing the boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"ScaleFixWaitBC (Scale Fix Wait Boundary Condition): This boundary condition applies a scaling factor to particles after a specified number of time steps. It allows particles to be scaled or deformed over time. It can be useful for simulating time-dependent deformations. For example, it can be used to gradually apply a scaling effect to particles at the boundary after a certain waiting period.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"ScaleFixWaitBC\nScaleFixWaitBC(bool, scale, fixpoint, wait, scalebool; applyafter=0, onlyatstart=false)","category":"page"},{"location":"bc.html#PeriDyn.ScaleFixWaitBC","page":"Boundary Conditions","title":"PeriDyn.ScaleFixWaitBC","text":"ScaleFixWaitBC\n\nStructure representing a ScaleFixWaitBC boundary condition.\n\nFields\n\nbool: Boolean array specifying the affected elements.\nlast: Last position of the affected elements.\nonlyatstart: Flag indicating if the boundary condition is applied only at the start.\nxF: function for updating the position.\nvF: function for updating the velocity.\ncheckF: Function for checking if the boundary condition needs to be applied.\n\n\n\n\n\n","category":"type"},{"location":"bc.html#PeriDyn.ScaleFixWaitBC-NTuple{5, Any}","page":"Boundary Conditions","title":"PeriDyn.ScaleFixWaitBC","text":"ScaleFixWaitBC(bool, scale, fixpoint, wait, scalebool; applyafter=0, onlyatstart=false)\n\nConstruct a ScaleFixWaitBC boundary condition.\n\nArguments\n\nbool: Boolean array specifying the affected elements.\nscale: Scale factor for the elements.\nfixpoint: Fix point for the elements.\nwait: Number of time steps to wait before applying the condition.\nscalebool: Boolean array specifying the elements to be scaled.\napplyafter: Number of time steps after which the condition is applied (default: 0).\nonlyatstart: Boolean indicating whether the condition is applied only at the start (default: false).\n\nReturns\n\nAn instance of ScaleFixWaitBC boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"bc.html#Custom-boundary-conditions","page":"Boundary Conditions","title":"Custom boundary conditions","text":"","category":"section"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"A custom boundary condition can also be defined by the user which should be a subtype of BoundaryCondition abstract type. These boundary conditions are applied to the position and velocity aspects of the particles in the simulation defined by xF and vF functions respectively. They define the behavior of the particles at the boundaries and can be customized based on the specific requirements of the simulation. apply_bc! and apply_bc_at0! functions are used to apply the boundary conditions to the particles in the simulation. The check! function is used to check if the boundary conditions are applied correctly to the particles in the simulation. apply_bc!, apply_bc_at0! and check! functions are defined for BoundaryCondition abstract type and can be overloaded by the user to define custom boundary conditions. The default implementation of these functions is as follows.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"\"\"\"\n    apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:position}})\n\nApply the general boundary condition `BC` to the position aspect\nof the given environment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The general boundary condition to apply.\n\"\"\"\nfunction apply_bc!(env, BC::T, ::Type{Val{:position}}) where\n                                        T <: BoundaryCondition\n    a, b = BC.xF(env, BC)\n    env.y[:, BC.bool] .= a\n    BC.last .= b\nend\n\n\"\"\"\n    apply_bc!(env, BC::BoundaryCondition, ::Type{Val{:velocity}})\n\nApply the general boundary condition `BC` to the velocity aspect of the\ngiven environment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The general boundary condition to apply.\n\"\"\"\nfunction apply_bc!(env, BC::T, ::Type{Val{:velocity}}) where\n                                        T <: BoundaryCondition\n    a, b = BC.vF(env, BC)\n    env.v[:, BC.bool] .= a\n    BC.last .= b\nend\n\n\"\"\"\n    apply_bc_at0!(env, BC::BoundaryCondition)\n\nApply the boundary condition `BC` to the given environment `env` at the\nstart of the simulation (t=0).\n\"\"\"\nfunction apply_bc_at0!(env, BC::T) where T <: BoundaryCondition\n    # error(\"check! method Not implemented for $(T)\")\n    log_detail(\"apply_bc_at0! method not implemented for $(T)\")\nend\n\n\"\"\"\n    check!(env, BC::BoundaryCondition)\n\nCheck if the boundary condition `BC` has changed and updates the `BC`.\nUsed for dynamic boundary conditions.\n\"\"\"\nfunction check!(env, BC::T) where T <: BoundaryCondition\n    # error(\"check! method Not implemented for $(T)\")\n    log_detail(\"check! method not implemented for $(T)\")\nend\n","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"The following code shows how one can define the CustomNameBC boundary condition.","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"\"\"\"\nThis module contains definitions for CustomNameBC boundary conditions.\n\"\"\"\n\nexport CustomNameBC\n\n\"\"\"\n    CustomNameBC\n\nStruct representing the CustomNameBC boundary condition.\n\n# Fields\n- `bool`: Boolean array specifying the affected elements.\n- `last`: Last position of the affected elements.\n- `onlyatstart`: Flag indicating if the boundary condition is applied\n    only at the start.\n- `xF`: function for updating the position.\n- `vF`: function for updating the velocity.\n\"\"\"\nstruct CustomNameBC <: BoundaryCondition\n    @general_bc_p\n    # macro will expand to:\n    # bool::AbstractArray{Bool, 1}\n    # last::AbstractArray{Float64, 2}\n    # onlyatstart::Bool\n    # xF::Function\n    # vF::Function\nend\n\n\n\"\"\"\n    CustomNameBC(args...; onlyatstart=false)\n\nConstruct a CustomNameBC boundary condition.\n\n# Arguments\n- `args`: Arguments for the boundary condition.\n- `onlyatstart`: Flag indicating if the boundary condition is applied only\n    at the start (default: `false`).\n\n# Returns\nA CustomNameBC object representing the boundary condition.\n\"\"\"\nfunction CustomNameBC(args...; onlyatstart=false)\n    last = zeros(Float64, SPATIAL_DIMENSIONS_REF[], sum(bool))\n    bool = # generate bool array depending on the args passed\n    xF = (env, BC) -> begin\n                        # write logic here\n                        (a, b)  # return a and b as the new position\n                                # and BC.last position\n                    end\n    vF = (env, BC) -> begin\n                        # write logic here\n                        (a, b)  # return a and b as the new velocity\n                                # and BC.last position\n    deviceconvert(CustomNameBC(bool, last, onlyatstart, xF, vF))\nend\n\n\"\"\"\n    apply_bc_at0!(env, BC::CustomNameBC)\n\nApply the CustomNameBC boundary condition at time 0 to the given\nenvironment `env`.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The CustomNameBC boundary condition to apply.\n\"\"\"\nfunction apply_bc_at0!(env, BC::CustomNameBC)\n    # write logic here for e.g. BC.last .= env.y[:, BC.bool]\nend\n\n\"\"\"\n    check!(env, BC::CustomNameBC)\n\nCheck if the CustomNameBC boundary condition has changed and updates\nthe `CustomNameBC`. Used for dynamic boundary conditions.\n\n# Arguments\n- `env`: The environment to which the boundary condition is applied.\n- `BC`: The CustomNameBC boundary condition to apply.\n\"\"\"\nfunction check!(env, BC::CustomNameBC)\n    # write logic here for e.g. BC.bool .= env.y[:, 1] .> 0.5\nend","category":"page"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"BoundaryCondition","category":"page"},{"location":"bc.html#PeriDyn.BoundaryCondition","page":"Boundary Conditions","title":"PeriDyn.BoundaryCondition","text":"BoundaryCondition\n\nAbstract type for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"bc.html","page":"Boundary Conditions","title":"Boundary Conditions","text":"apply_bc!\napply_bc_at0!\ncheck!","category":"page"},{"location":"bc.html#PeriDyn.apply_bc!","page":"Boundary Conditions","title":"PeriDyn.apply_bc!","text":"apply_bc!(env, BC::BoundaryCondition, on::Symbol)\n\nApply the specified boundary condition BC to the given environment env on the specified aspect on.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The boundary condition to apply.\non::Symbol: The aspect on which the boundary condition is applied (:position or :velocity).\n\n\n\n\n\napply_bc!(env, BC::BoundaryCondition, ::Type{Val{:position}})\n\nApply the general boundary condition BC to the position aspect of the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The general boundary condition to apply.\n\n\n\n\n\napply_bc!(env, BC::BoundaryCondition, ::Type{Val{:velocity}})\n\nApply the general boundary condition BC to the velocity aspect of the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The general boundary condition to apply.\n\n\n\n\n\n","category":"function"},{"location":"bc.html#PeriDyn.apply_bc_at0!","page":"Boundary Conditions","title":"PeriDyn.apply_bc_at0!","text":"apply_bc_at0!(env, BC::BoundaryCondition)\n\nApply the boundary condition BC to the given environment env at the start of the simulation (t=0).\n\n\n\n\n\napply_bc_at0!(env, BC::FixBC)\n\nApply the FixBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The FixBC boundary condition to apply.\n\n\n\n\n\napply_bc_at0!(env, BC::ToFroBC)\n\nApply the ToFroBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The ToFroBC boundary condition to apply.\n\n\n\n\n\napply_bc_at0!(env, BC::DeltaScaleBC)\n\nApply the DeltaScaleBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The DeltaScaleBC boundary condition to apply.\n\n\n\n\n\napply_bc_at0!(env, BC::ScaleFixWaitBC)\n\nApply the ScaleFixWaitBC boundary condition at time 0.\n\nArguments\n\nenv: Environment in which the condition is applied.\nBC: Instance of ScaleFixWaitBC boundary condition.\n\n\n\n\n\napply_bc_at0!(env, BC::ContainerBC)\n\nApply the ContainerBC boundary condition at time 0 to the given environment env.\n\nArguments\n\nenv: The environment to which the boundary condition is applied.\nBC: The ContainerBC boundary condition to apply.\n\n\n\n\n\n","category":"function"},{"location":"bc.html#PeriDyn.check!","page":"Boundary Conditions","title":"PeriDyn.check!","text":"check!(env, BC::BoundaryCondition)\n\nCheck if the boundary condition BC has changed and updates the BC. Used for dynamic boundary conditions.\n\n\n\n\n\ncheck!(BC::ToFroBC, env)\n\nPerform a check on the ToFroBC boundary condition.\n\nArguments\n\nBC: The ToFroBC boundary condition to check.\nenv: The environment associated with the boundary condition.\n\n\n\n\n\ncheck!(BC::DeltaScaleBC, env)\n\nPerform a check on the DeltaScaleBC boundary condition.\n\nArguments\n\nBC: The DeltaScaleBC boundary condition to check.\nenv: The environment associated with the boundary condition.\n\n\n\n\n\ncheck!(BC::ScaleFixWaitBC, env)\n\nCheck if the ScaleFixWaitBC boundary condition needs to be applied.\n\nArguments\n\nBC: Instance of ScaleFixWaitBC boundary condition.\nenv: Environment in which the condition is applied.\n\n\n\n\n\n","category":"function"},{"location":"materialgeometry.html","page":"Material Geometry","title":"Material Geometry","text":"Creating material points for a given geometry can be done using MaterialPoints.jl package. Please see the package documentation and examples.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html#Basic-examples","page":"Examples","title":"Basic examples","text":"","category":"section"},{"location":"examples.html#Tensile-simulation-of-a-bar","page":"Examples","title":"Tensile simulation of a bar","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To simulate the tensile behavior of a bar using the PeriDyn package, you can follow these steps:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Activate the PeriDyn environment by running the following code from the PeriDyn package directory. This will activate the environment and install the required packages or install package first.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Import the PeriDyn and PDMaterialPoints packages.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using PeriDyn\nusing PDMaterialPoints","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Create the geometry of the material block using a Cuboid shape and a specified resolution. Then create a material generator using the created geometry and resolution. In this example, we create a bar with dimensions 20x5x5 mm and a resolution of 0.5 mm.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"info: Info\nUnits are abstracted in the PeriDyn package, so you can use any unit system as long as it is consistent.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"resolution = 0.5\n\nx1, v1, y1, vol1, type1 = unpack(create(Cuboid([0 20; 0 5; 0 5]), resolution=resolution))  # mm\nmat_gen1 = GeneralMaterial(y1, v1, x1, vol1, type1, 3.0*resolution; max_neigh=200)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Define the material parameters such as Young's modulus (Es), Poisson's ratio (nu), density (den), and critical stretch (cstretch). Then create a bond-based material block using the specified material parameters:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Es = 70 # GPa\nnu = 0.15\nK = Es/3/(1-2nu)\nG = Es/2/(1+nu)\nden = 2.2 * 1000.0 # Kg/m3\ncstretch = 0.15\n\nmat_spec1 = BondBasedSpecific([K], [cstretch], [den])\n# mat_spec1 = OrdinaryStateBasedSpecific([K], [G], [cstretch], [den])\n\nblock1 = PeridynamicsMaterial(mat_gen1, mat_spec1)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Choose a solver for the simulation. In this example, we use the DSVelocityVerlet solver and set the number of steps (Steps), file write frequency (fwf), and neighbor update frequency (nuf):","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"solver = DSVelocityVerlet()\nSteps, fwf, nuf = 2000, 100, 10","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Define the boundary conditions for the simulation. Here, we fix the left part of the bar (y1[1, :] .< 4.0) and move the right part of the bar (y1[1, :] .> 16.0) with a constant velocity:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"BC1 = FixBC(y1[1, :] .< 4.0)\nvelocity = [0.05*20/Steps/dt, 0.0, 0.0]\nBC2 = MoveBC(y1[1, :] .> 16.0, velocity)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Define a repulsive contact model. In this example, we use a LinearRepulsionModel with a spring constant (k) and the material block defined earlier (block1):","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"k = 1.0\nRM1 = LinearRepulsionModel(k, block1; distanceX=3, max_neighs=200)\nRMs = [RM1]","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Create a PeriDyn environment by specifying the material blocks, repulsion models, boundary conditions, and time step (dt):","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"dt = 1e-3\nenv = PeriDyn.Env(1, [block1], RMs, [BC1, BC2], dt)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Customize the PeriDyn environment by setting parameters and defining a collection function. In this example, we set the \"left\" parameter to select the left part of the bar and collect the force values in the \"Out\" dictionary:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"env.Params = Dict(\"left\" => (y\n\n1[1,:] .< 4))\n\nenv.Out = Dict(\"Force\" => zeros(3, Steps))\n\nenv.Collect! = function (env, step)\n    env.Out[\"Force\"][:, step] = sum(env.f[:, env.Params[\"left\"]], dims=2)\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Run the simulation using the run! function and specify the number of steps, solver, file write frequency, output directory, and start index. Additionally, write the simulation output to a JLD file or Ovito files for visualization:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"out_dir = \"./output/tensile_sim_BB/$(typeof(solver))\"\n\nrun!([env], Steps, solver;\n    filewrite_freq=fwf, neigh_update_freq=nuf, out_dir=out_dir, start_at=0, ext=:jld)\n\nPeriDyn.write_data(\"$(out_dir)/env_Out.jld\"; Out=env.Out)\n\nPeriDyn.jld2ovito(\"$(out_dir)/env_1_step_*.jld\", Steps; start=0, step=fwf)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"By following these steps, you can perform a tensile simulation of a bar using the PeriDyn package and visualize the results using Ovito.","category":"page"},{"location":"list.html","page":"-","title":"-","text":"CurrentModule = PeriDyn","category":"page"},{"location":"list.html","page":"-","title":"-","text":"","category":"page"},{"location":"index.html#PeriDyn.jl","page":"Home","title":"PeriDyn.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: diskdamage)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriDyn is a numerical simulation software designed to solve peridynamics problems. It is written in the Julia programming language, and offers a high level of flexibility and speed. PDBenchmark is built on top of the PeriDyn package, which provides a number of predefined material models and benchmark problems. This allows users to quickly set up and run simulations, and compare their results to established benchmarks.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"info: Info\nPlease see the post for more information about the PeriDyn.jl package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Peridynamics is a nonlocal continuum theory that can describe material failure and fracture without using the traditional concepts of stress and strain. Instead, it models a material as a collection of particles that interact through pairwise forces. These forces depend on the separation between particles, and can be used to simulate a wide range of materials, including brittle and ductile solids, fluids, and granular materials.","category":"page"}]
}
